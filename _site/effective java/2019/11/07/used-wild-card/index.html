
<!doctype html>














<html class="theme-next muse use-motion" lang="ko">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/assets/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/assets/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/assets/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="" />





  <link rel="alternate" href="/atom.xml" title="Notepad" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/assets/favicon.ico?v=5.1.1" />
















<meta name="description" content="한정적 와일드카드 형인자 자료형은 불변 자료형이다. List&amp;lt;Object&amp;gt;랑 List&amp;lt;String&amp;gt;은 같지 않다는 말이다. 직관적으로 이해하기 어렵겠지만 이치에는 맞는 말이다. 때로는 이보다 높은 유연성이 필요할 때가 있다. 전에 만들었던 스택 클래스는 아래와 같은 public API를 갖는다. public class Stack&amp;lt;E&amp;gt; { public Stack(); public void push(E e); public E pop(); public boolean isEmpty(); } 여기에, 일령의 원소들을 인자로 받아 차례로 스택에 집어넣는 메서드를 추가 해보자. 아마 이런 코드를 만들게 될것이다. // 와일드카드 자료형을 사용하지 않는 pushAll 메서드 - 문제가 있다. public void pushAll(Iterable&amp;lt;E&amp;gt; src) { for (E e : src) { push(e); } } 이 메서드는 깔끔하게 컴파일되고 제대로 동작할것같다. 스택이 Stack&amp;lt;Number&amp;gt;이라고 생각해보자 그러면 Integer 이나 Double이 제대로 들어가고 정상작동할 것이라고 생각한다. 다음 코드 처럼 말이다. Stack&amp;lt;Number&amp;gt; numberStack = new Stack&amp;lt;Number&amp;gt;(); Iterable&amp;lt;Integer&amp;gt; integers = ...; numberStack.pushAll(integers); 하지만 실제로 해 보면 아래와 같은 오류 메시지가 출력된다. StackTest.java: pushAll(Iterable&amp;lt;Number&amp;gt;) in Stack&amp;lt;Number&amp;gt; Cannot be applied to (Iterable&amp;lt;Integer&amp;gt;) numberStack.pushAll(integers); ＾ 형인자 자료형은 불변이기 때문이다. 다행히도 이문제를 해결할 수 있다. 한정적 와일드 카드를 사용하면된다. pushAll의 인자 자료형을 “E의 Iterable”이 아니라 “E의 하위 자료형의 Iterable”이라고 명시하기 위해 Iterable&amp;lt;? extends E&amp;gt;를 사용한다. // E 객체 생산자 역할을 하는 인자에 대한 와일드카드 자료형 public void pushAll(Iterable&amp;lt;? extends E&amp;gt; src) { for (E e : src) { push(e); } } 이렇게 만들면 전에 나오던 경고문이 사라질 뿐더러 형안전성이 확보된다. 이와 같이 popAll 메서드도 만들어 보자. // 와일드카드 자료형 없이 구현한 popAll 메서드 - 문제가 있다. public void popAll(Collection&amp;lt;E&amp;gt; dst) { while (!isEmptu()) { dst.add(pop()); } } 이 메서드는 깔끔하게 컴파일될 뿐 아니라 인자로 주어진 컬렉션의 원소 자료형이 스택의 원소 자료형과 일치할 때는 완벽히 동작한다. 하지만 스택이 Stack&amp;lt;Number&amp;gt;이고 Object 형의 변수가 하나 있다고 하자. 스택에서 원소 하나를 꺼내서 해당 변수에 대입하는 코드는 오류 없이 컴파일하고 실행할 수 있다. 그렇다면 아래와 같은 코드도 만들 수 있어야 하지 않을까? Stack&amp;lt;Number&amp;gt; numberStack = new Stack&amp;lt;Number&amp;gt;(); Collection&amp;lt;Object&amp;gt; objects = ...; numberStack.popAll(objects); 이 코드를 컴파일 해보면 pushAll 메서드에서 발생한 오류와 비슷한 오류가 발생한다. Collection&amp;lt;Object&amp;gt;가 Collection&amp;lt;Number&amp;gt;의 하위 자료형이 아니라는 오류가 난다는 것이다. 이 문제도 와일드카드 자료형을 쓰면 극복할 수 있다. popAll의 인자 자료형을 “E의 컬렉션”이 아니라 “E의 상위 자료형의 컬렉션”이라고 명시하는 것이다. 그러면 다음과 같이 코드를 수정해보자. // E의 소비자 구실을 하는 인자에 대한 와일드카드 자료형 public void popAll(Collection&amp;lt;? super E&amp;gt; dst) { while (!isEmpty()) { dst.add(pop()); } } 이렇게 바꾸면 Stack과 클라이언트 코드는 깔끔하게 컴파일된다. 유연성을 최대화 하려면 객체 생산자나 소비자 구실을 하는 메서드 인자의 자료형은 와일드카드 자료형으로 하라는 것이다. 이 때, 어떤 와일드카드 자료형을 쓸지 모르겠다면 다음을 참고하자. PECS (Produce - Extends, Consumer - Super) 그러니까, 인자가 T 생산자라면 &amp;lt;? extends T&amp;gt;라고 하고 T 소비자라면 &amp;lt;? super T&amp;gt;라고 하라는 것이다. 연습으로 전에 만들었던 메서드들에 적용 시켜보자. static &amp;lt;E&amp;gt; reduce(List&amp;lt;E&amp;gt; list, FUnction&amp;lt;E&amp;gt; f, E initVal) /* list 인자를 E 생산자로만 사용하므로 와일드카드 자료형 &quot;? extends E&quot;로 선언 f는 생산자와 소비자가 동일하기 때문에 와일드카드 자료형을 사용하면 안된다. */ // E 생산자 구실을 하는 인자에 와일드카드 자료형 적용 static &amp;lt;E&amp;gt; E reduce(List&amp;lt;? extends E&amp;gt; list, Function&amp;lt;E&amp;gt; f, E initVal) public static &amp;lt;E&amp;gt; Set&amp;lt;E&amp;gt; union(Set&amp;lt;E&amp;gt; s1, Set&amp;lt;E&amp;gt; s2) // 인자 모두가 전부 생산자 이므로 다음과 같이 고쳐진다. public static &amp;lt;E&amp;gt; Set&amp;lt;E&amp;gt; union(Set&amp;lt;? extends E&amp;gt; s1, Set&amp;lt;? extends E&amp;gt; s2) public static &amp;lt;T extends Comparable&amp;lt;T&amp;gt;&amp;gt; T max(LIst&amp;lt;T&amp;gt; list) // list는 T 객체의 생산자이므로 자료형을 List&amp;lt;? extends T&amp;gt;로 변경 // Comparable는 항상 소비자이므로 &amp;lt;? super T&amp;gt;로 변경 public static &amp;lt;T extends Comparable&amp;lt;? super T&amp;gt;&amp;gt; T max(List&amp;lt;? extends T&amp;gt; list) // 이렇게 고치면 더 광범위하게 사용할 수 있다 List&amp;lt;ScheduledFuture&amp;lt;?&amp;gt;&amp;gt; scheduledFutures = ...; 원래 메서드가 위의 리스트에 적요될 수 없는 것은 ScheduledFuture가 Comparable&amp;lt;ScheduledFuture&amp;gt;를 구현하지 않기 때문이다. ScheduledFuture는 Comparable&amp;lt;Delayed&amp;gt;를 확장하는 Delayed의 하위 인터페이스이다. 다시 말해서, ScheduledFuture 객체는 단순히 다른 ScheduledFuture 객체들하고만 비교할 수 있는 것이 아니다. 어느 Delayed 객체와도 비교가 가능하다. 그래서 수정되기 전의 선언부로는 처리할 수 없는 것이다. 선언부를 수정하고 컴파일하게 되면 아래와 같은 오류가 뜬다. Max.java: incompatible types found: Iterator&amp;lt;capture#591 of ? extends T&amp;gt; required: Iterator&amp;lt;T&amp;gt; Iterator&amp;lt;T&amp;gt; i = list.iterator(); ＾ 이 오류는 list가 List&amp;lt;T&amp;gt;가 아니므로 iterator 메서드가 Iterator&amp;lt;T&amp;gt;를 반환하지 않는다는 뜻이다. 따라서 아래와 같이 내부를 수정하면 된다. public static &amp;lt;T extends Comparable&amp;lt;? super T&amp;gt;&amp;gt; T max(List&amp;lt;? extends T&amp;gt; list) { Iterator&amp;lt;? extends T&amp;gt; i = list.iterator(); T result = i.next(); while (i.hasNext()) { T t = i.next(); if (t.compateTo(result) &amp;gt; 0) { result = t; } } return result; } 반환값에는 와일드카드 자료형을 사용하면 안된다. 좀 더 유연한 코드를 만들 수 있도록 도와주기는커녕, 클라이언트 코드 안에도 와일드카드 자료형을 명시해야 하기 때문이다. 또한, 클래스 사용자가 와일드카드 자료형에 대해 고민하게 된다면, 그것은 아마도 클래스 API가 잘못 설계된 탓일 것이다. 형인자와 와일드카드 사이에 존재하는 이원성 상당수의 메서드를 선언하는 방법에는 두 가지 방법 중 어떤 것으로도 선언될 수 있다는 것이다. swap 메서드를 예제로 들어보자. public static &amp;lt;E&amp;gt; void swap(List&amp;lt;E&amp;gt; list, int i, int j); public static void swap(List&amp;lt;?&amp;gt; list, int i, int j); 두 가지 방법 모두 옳은 방법이지만 public API를 만들고 있다면 두 번째 방법이 더 바람직하다. 형인자를 신경 쓸 필요가 없어져서 더 간단하기 때문이다. 원칙은, 형인자가 메서드 선언에 단 한군데 나타난다면 해당 인자를 와일드카드로 바꾸라는 것이다. 비한정적 형인자이면 비한정적 와일드카드로 바꾸고, 한정적 형인자이면 한정적 와일드카드로 바꾸라. 그런데 형인자 대신 와일드카드를 사용한 swap의 두 번째 선언에는 한 가지 문제가 있다. 당연해 보이는 코드가 컴파일되지 않는 것이다. public static void swap(List&amp;lt;?&amp;gt; list, int i, int j) { list.set(i, list.set(j, list.get(i))); } 다음과 같은 오류가 발생한다. Swap.java: set(int, capture#282 of ?) in List&amp;lt;capture#282 of ?&amp;gt; cannot be aplied to (int,Object) list.set(i, list.set(j, list.get(i))); ＾ 리스트에서 방금 꺼낸 원소를 그 리스트에 다시 넣을 수 없다는 것은 옳지 않아 보인다. 문제는 list의 자료형이 List&amp;lt;?&amp;gt;라는 것이다. List&amp;lt;?&amp;gt;에는 null 이외의 어떤 값도 넣을 수 없다. 다행히도 형 안전성이 보장되지 않는 형변환이나 무인자 자료형을 쓰지 않고도 이 문제를 해겨할 수 있다. private 도움 메서드를 이용해 와일드카드 자료형을 포착하는 것이 기본적인 아이디어이다. 이 도움 메서드는 제네릭 메서드로 정의해야 한다. 그래야 자료형을 포착할 수 있다. public static void swap(List&amp;lt;?&amp;gt; list, int i, int j) // 와일드카드 자료형을 포착하기 위한 private 도움 메서드 private static &amp;lt;E&amp;gt; void swapHelper(List&amp;lt;E&amp;gt; list, int i, int j) { list.set(i, list.set(j, list.get(i))); } swapHelper 메서드는 list가 List&amp;lt;E&amp;gt;라는 것을 안다. 따라서 해당 리스트에서 꺼낸 값의 자료형은 E다. 그리고 E 형의 값은 리스트에 넣어도 안전하다. 조금 복잡해 보이지만 이 코드는 깔끔하게 컴파일된다.">
<meta name="keywords" content="Jekyll, NexT">
<meta property="og:type" content="article">
<meta property="og:title" content="[Effective Java] 한정적 와일드카드를 써서 API 유연성을 높여라">
<meta property="og:url" content="http://localhost:4000/effective%20java/2019/11/07/used-wild-card/">
<meta property="og:site_name" content="Notepad">
<meta property="og:description" content="한정적 와일드카드 형인자 자료형은 불변 자료형이다. List&amp;lt;Object&amp;gt;랑 List&amp;lt;String&amp;gt;은 같지 않다는 말이다. 직관적으로 이해하기 어렵겠지만 이치에는 맞는 말이다. 때로는 이보다 높은 유연성이 필요할 때가 있다. 전에 만들었던 스택 클래스는 아래와 같은 public API를 갖는다. public class Stack&amp;lt;E&amp;gt; { public Stack(); public void push(E e); public E pop(); public boolean isEmpty(); } 여기에, 일령의 원소들을 인자로 받아 차례로 스택에 집어넣는 메서드를 추가 해보자. 아마 이런 코드를 만들게 될것이다. // 와일드카드 자료형을 사용하지 않는 pushAll 메서드 - 문제가 있다. public void pushAll(Iterable&amp;lt;E&amp;gt; src) { for (E e : src) { push(e); } } 이 메서드는 깔끔하게 컴파일되고 제대로 동작할것같다. 스택이 Stack&amp;lt;Number&amp;gt;이라고 생각해보자 그러면 Integer 이나 Double이 제대로 들어가고 정상작동할 것이라고 생각한다. 다음 코드 처럼 말이다. Stack&amp;lt;Number&amp;gt; numberStack = new Stack&amp;lt;Number&amp;gt;(); Iterable&amp;lt;Integer&amp;gt; integers = ...; numberStack.pushAll(integers); 하지만 실제로 해 보면 아래와 같은 오류 메시지가 출력된다. StackTest.java: pushAll(Iterable&amp;lt;Number&amp;gt;) in Stack&amp;lt;Number&amp;gt; Cannot be applied to (Iterable&amp;lt;Integer&amp;gt;) numberStack.pushAll(integers); ＾ 형인자 자료형은 불변이기 때문이다. 다행히도 이문제를 해결할 수 있다. 한정적 와일드 카드를 사용하면된다. pushAll의 인자 자료형을 “E의 Iterable”이 아니라 “E의 하위 자료형의 Iterable”이라고 명시하기 위해 Iterable&amp;lt;? extends E&amp;gt;를 사용한다. // E 객체 생산자 역할을 하는 인자에 대한 와일드카드 자료형 public void pushAll(Iterable&amp;lt;? extends E&amp;gt; src) { for (E e : src) { push(e); } } 이렇게 만들면 전에 나오던 경고문이 사라질 뿐더러 형안전성이 확보된다. 이와 같이 popAll 메서드도 만들어 보자. // 와일드카드 자료형 없이 구현한 popAll 메서드 - 문제가 있다. public void popAll(Collection&amp;lt;E&amp;gt; dst) { while (!isEmptu()) { dst.add(pop()); } } 이 메서드는 깔끔하게 컴파일될 뿐 아니라 인자로 주어진 컬렉션의 원소 자료형이 스택의 원소 자료형과 일치할 때는 완벽히 동작한다. 하지만 스택이 Stack&amp;lt;Number&amp;gt;이고 Object 형의 변수가 하나 있다고 하자. 스택에서 원소 하나를 꺼내서 해당 변수에 대입하는 코드는 오류 없이 컴파일하고 실행할 수 있다. 그렇다면 아래와 같은 코드도 만들 수 있어야 하지 않을까? Stack&amp;lt;Number&amp;gt; numberStack = new Stack&amp;lt;Number&amp;gt;(); Collection&amp;lt;Object&amp;gt; objects = ...; numberStack.popAll(objects); 이 코드를 컴파일 해보면 pushAll 메서드에서 발생한 오류와 비슷한 오류가 발생한다. Collection&amp;lt;Object&amp;gt;가 Collection&amp;lt;Number&amp;gt;의 하위 자료형이 아니라는 오류가 난다는 것이다. 이 문제도 와일드카드 자료형을 쓰면 극복할 수 있다. popAll의 인자 자료형을 “E의 컬렉션”이 아니라 “E의 상위 자료형의 컬렉션”이라고 명시하는 것이다. 그러면 다음과 같이 코드를 수정해보자. // E의 소비자 구실을 하는 인자에 대한 와일드카드 자료형 public void popAll(Collection&amp;lt;? super E&amp;gt; dst) { while (!isEmpty()) { dst.add(pop()); } } 이렇게 바꾸면 Stack과 클라이언트 코드는 깔끔하게 컴파일된다. 유연성을 최대화 하려면 객체 생산자나 소비자 구실을 하는 메서드 인자의 자료형은 와일드카드 자료형으로 하라는 것이다. 이 때, 어떤 와일드카드 자료형을 쓸지 모르겠다면 다음을 참고하자. PECS (Produce - Extends, Consumer - Super) 그러니까, 인자가 T 생산자라면 &amp;lt;? extends T&amp;gt;라고 하고 T 소비자라면 &amp;lt;? super T&amp;gt;라고 하라는 것이다. 연습으로 전에 만들었던 메서드들에 적용 시켜보자. static &amp;lt;E&amp;gt; reduce(List&amp;lt;E&amp;gt; list, FUnction&amp;lt;E&amp;gt; f, E initVal) /* list 인자를 E 생산자로만 사용하므로 와일드카드 자료형 &quot;? extends E&quot;로 선언 f는 생산자와 소비자가 동일하기 때문에 와일드카드 자료형을 사용하면 안된다. */ // E 생산자 구실을 하는 인자에 와일드카드 자료형 적용 static &amp;lt;E&amp;gt; E reduce(List&amp;lt;? extends E&amp;gt; list, Function&amp;lt;E&amp;gt; f, E initVal) public static &amp;lt;E&amp;gt; Set&amp;lt;E&amp;gt; union(Set&amp;lt;E&amp;gt; s1, Set&amp;lt;E&amp;gt; s2) // 인자 모두가 전부 생산자 이므로 다음과 같이 고쳐진다. public static &amp;lt;E&amp;gt; Set&amp;lt;E&amp;gt; union(Set&amp;lt;? extends E&amp;gt; s1, Set&amp;lt;? extends E&amp;gt; s2) public static &amp;lt;T extends Comparable&amp;lt;T&amp;gt;&amp;gt; T max(LIst&amp;lt;T&amp;gt; list) // list는 T 객체의 생산자이므로 자료형을 List&amp;lt;? extends T&amp;gt;로 변경 // Comparable는 항상 소비자이므로 &amp;lt;? super T&amp;gt;로 변경 public static &amp;lt;T extends Comparable&amp;lt;? super T&amp;gt;&amp;gt; T max(List&amp;lt;? extends T&amp;gt; list) // 이렇게 고치면 더 광범위하게 사용할 수 있다 List&amp;lt;ScheduledFuture&amp;lt;?&amp;gt;&amp;gt; scheduledFutures = ...; 원래 메서드가 위의 리스트에 적요될 수 없는 것은 ScheduledFuture가 Comparable&amp;lt;ScheduledFuture&amp;gt;를 구현하지 않기 때문이다. ScheduledFuture는 Comparable&amp;lt;Delayed&amp;gt;를 확장하는 Delayed의 하위 인터페이스이다. 다시 말해서, ScheduledFuture 객체는 단순히 다른 ScheduledFuture 객체들하고만 비교할 수 있는 것이 아니다. 어느 Delayed 객체와도 비교가 가능하다. 그래서 수정되기 전의 선언부로는 처리할 수 없는 것이다. 선언부를 수정하고 컴파일하게 되면 아래와 같은 오류가 뜬다. Max.java: incompatible types found: Iterator&amp;lt;capture#591 of ? extends T&amp;gt; required: Iterator&amp;lt;T&amp;gt; Iterator&amp;lt;T&amp;gt; i = list.iterator(); ＾ 이 오류는 list가 List&amp;lt;T&amp;gt;가 아니므로 iterator 메서드가 Iterator&amp;lt;T&amp;gt;를 반환하지 않는다는 뜻이다. 따라서 아래와 같이 내부를 수정하면 된다. public static &amp;lt;T extends Comparable&amp;lt;? super T&amp;gt;&amp;gt; T max(List&amp;lt;? extends T&amp;gt; list) { Iterator&amp;lt;? extends T&amp;gt; i = list.iterator(); T result = i.next(); while (i.hasNext()) { T t = i.next(); if (t.compateTo(result) &amp;gt; 0) { result = t; } } return result; } 반환값에는 와일드카드 자료형을 사용하면 안된다. 좀 더 유연한 코드를 만들 수 있도록 도와주기는커녕, 클라이언트 코드 안에도 와일드카드 자료형을 명시해야 하기 때문이다. 또한, 클래스 사용자가 와일드카드 자료형에 대해 고민하게 된다면, 그것은 아마도 클래스 API가 잘못 설계된 탓일 것이다. 형인자와 와일드카드 사이에 존재하는 이원성 상당수의 메서드를 선언하는 방법에는 두 가지 방법 중 어떤 것으로도 선언될 수 있다는 것이다. swap 메서드를 예제로 들어보자. public static &amp;lt;E&amp;gt; void swap(List&amp;lt;E&amp;gt; list, int i, int j); public static void swap(List&amp;lt;?&amp;gt; list, int i, int j); 두 가지 방법 모두 옳은 방법이지만 public API를 만들고 있다면 두 번째 방법이 더 바람직하다. 형인자를 신경 쓸 필요가 없어져서 더 간단하기 때문이다. 원칙은, 형인자가 메서드 선언에 단 한군데 나타난다면 해당 인자를 와일드카드로 바꾸라는 것이다. 비한정적 형인자이면 비한정적 와일드카드로 바꾸고, 한정적 형인자이면 한정적 와일드카드로 바꾸라. 그런데 형인자 대신 와일드카드를 사용한 swap의 두 번째 선언에는 한 가지 문제가 있다. 당연해 보이는 코드가 컴파일되지 않는 것이다. public static void swap(List&amp;lt;?&amp;gt; list, int i, int j) { list.set(i, list.set(j, list.get(i))); } 다음과 같은 오류가 발생한다. Swap.java: set(int, capture#282 of ?) in List&amp;lt;capture#282 of ?&amp;gt; cannot be aplied to (int,Object) list.set(i, list.set(j, list.get(i))); ＾ 리스트에서 방금 꺼낸 원소를 그 리스트에 다시 넣을 수 없다는 것은 옳지 않아 보인다. 문제는 list의 자료형이 List&amp;lt;?&amp;gt;라는 것이다. List&amp;lt;?&amp;gt;에는 null 이외의 어떤 값도 넣을 수 없다. 다행히도 형 안전성이 보장되지 않는 형변환이나 무인자 자료형을 쓰지 않고도 이 문제를 해겨할 수 있다. private 도움 메서드를 이용해 와일드카드 자료형을 포착하는 것이 기본적인 아이디어이다. 이 도움 메서드는 제네릭 메서드로 정의해야 한다. 그래야 자료형을 포착할 수 있다. public static void swap(List&amp;lt;?&amp;gt; list, int i, int j) // 와일드카드 자료형을 포착하기 위한 private 도움 메서드 private static &amp;lt;E&amp;gt; void swapHelper(List&amp;lt;E&amp;gt; list, int i, int j) { list.set(i, list.set(j, list.get(i))); } swapHelper 메서드는 list가 List&amp;lt;E&amp;gt;라는 것을 안다. 따라서 해당 리스트에서 꺼낸 값의 자료형은 E다. 그리고 E 형의 값은 리스트에 넣어도 안전하다. 조금 복잡해 보이지만 이 코드는 깔끔하게 컴파일된다.">
<meta property="og:locale" content="ko">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="[Effective Java] 한정적 와일드카드를 써서 API 유연성을 높여라">
<meta name="twitter:description" content="한정적 와일드카드 형인자 자료형은 불변 자료형이다. List&amp;lt;Object&amp;gt;랑 List&amp;lt;String&amp;gt;은 같지 않다는 말이다. 직관적으로 이해하기 어렵겠지만 이치에는 맞는 말이다. 때로는 이보다 높은 유연성이 필요할 때가 있다. 전에 만들었던 스택 클래스는 아래와 같은 public API를 갖는다. public class Stack&amp;lt;E&amp;gt; { public Stack(); public void push(E e); public E pop(); public boolean isEmpty(); } 여기에, 일령의 원소들을 인자로 받아 차례로 스택에 집어넣는 메서드를 추가 해보자. 아마 이런 코드를 만들게 될것이다. // 와일드카드 자료형을 사용하지 않는 pushAll 메서드 - 문제가 있다. public void pushAll(Iterable&amp;lt;E&amp;gt; src) { for (E e : src) { push(e); } } 이 메서드는 깔끔하게 컴파일되고 제대로 동작할것같다. 스택이 Stack&amp;lt;Number&amp;gt;이라고 생각해보자 그러면 Integer 이나 Double이 제대로 들어가고 정상작동할 것이라고 생각한다. 다음 코드 처럼 말이다. Stack&amp;lt;Number&amp;gt; numberStack = new Stack&amp;lt;Number&amp;gt;(); Iterable&amp;lt;Integer&amp;gt; integers = ...; numberStack.pushAll(integers); 하지만 실제로 해 보면 아래와 같은 오류 메시지가 출력된다. StackTest.java: pushAll(Iterable&amp;lt;Number&amp;gt;) in Stack&amp;lt;Number&amp;gt; Cannot be applied to (Iterable&amp;lt;Integer&amp;gt;) numberStack.pushAll(integers); ＾ 형인자 자료형은 불변이기 때문이다. 다행히도 이문제를 해결할 수 있다. 한정적 와일드 카드를 사용하면된다. pushAll의 인자 자료형을 “E의 Iterable”이 아니라 “E의 하위 자료형의 Iterable”이라고 명시하기 위해 Iterable&amp;lt;? extends E&amp;gt;를 사용한다. // E 객체 생산자 역할을 하는 인자에 대한 와일드카드 자료형 public void pushAll(Iterable&amp;lt;? extends E&amp;gt; src) { for (E e : src) { push(e); } } 이렇게 만들면 전에 나오던 경고문이 사라질 뿐더러 형안전성이 확보된다. 이와 같이 popAll 메서드도 만들어 보자. // 와일드카드 자료형 없이 구현한 popAll 메서드 - 문제가 있다. public void popAll(Collection&amp;lt;E&amp;gt; dst) { while (!isEmptu()) { dst.add(pop()); } } 이 메서드는 깔끔하게 컴파일될 뿐 아니라 인자로 주어진 컬렉션의 원소 자료형이 스택의 원소 자료형과 일치할 때는 완벽히 동작한다. 하지만 스택이 Stack&amp;lt;Number&amp;gt;이고 Object 형의 변수가 하나 있다고 하자. 스택에서 원소 하나를 꺼내서 해당 변수에 대입하는 코드는 오류 없이 컴파일하고 실행할 수 있다. 그렇다면 아래와 같은 코드도 만들 수 있어야 하지 않을까? Stack&amp;lt;Number&amp;gt; numberStack = new Stack&amp;lt;Number&amp;gt;(); Collection&amp;lt;Object&amp;gt; objects = ...; numberStack.popAll(objects); 이 코드를 컴파일 해보면 pushAll 메서드에서 발생한 오류와 비슷한 오류가 발생한다. Collection&amp;lt;Object&amp;gt;가 Collection&amp;lt;Number&amp;gt;의 하위 자료형이 아니라는 오류가 난다는 것이다. 이 문제도 와일드카드 자료형을 쓰면 극복할 수 있다. popAll의 인자 자료형을 “E의 컬렉션”이 아니라 “E의 상위 자료형의 컬렉션”이라고 명시하는 것이다. 그러면 다음과 같이 코드를 수정해보자. // E의 소비자 구실을 하는 인자에 대한 와일드카드 자료형 public void popAll(Collection&amp;lt;? super E&amp;gt; dst) { while (!isEmpty()) { dst.add(pop()); } } 이렇게 바꾸면 Stack과 클라이언트 코드는 깔끔하게 컴파일된다. 유연성을 최대화 하려면 객체 생산자나 소비자 구실을 하는 메서드 인자의 자료형은 와일드카드 자료형으로 하라는 것이다. 이 때, 어떤 와일드카드 자료형을 쓸지 모르겠다면 다음을 참고하자. PECS (Produce - Extends, Consumer - Super) 그러니까, 인자가 T 생산자라면 &amp;lt;? extends T&amp;gt;라고 하고 T 소비자라면 &amp;lt;? super T&amp;gt;라고 하라는 것이다. 연습으로 전에 만들었던 메서드들에 적용 시켜보자. static &amp;lt;E&amp;gt; reduce(List&amp;lt;E&amp;gt; list, FUnction&amp;lt;E&amp;gt; f, E initVal) /* list 인자를 E 생산자로만 사용하므로 와일드카드 자료형 &quot;? extends E&quot;로 선언 f는 생산자와 소비자가 동일하기 때문에 와일드카드 자료형을 사용하면 안된다. */ // E 생산자 구실을 하는 인자에 와일드카드 자료형 적용 static &amp;lt;E&amp;gt; E reduce(List&amp;lt;? extends E&amp;gt; list, Function&amp;lt;E&amp;gt; f, E initVal) public static &amp;lt;E&amp;gt; Set&amp;lt;E&amp;gt; union(Set&amp;lt;E&amp;gt; s1, Set&amp;lt;E&amp;gt; s2) // 인자 모두가 전부 생산자 이므로 다음과 같이 고쳐진다. public static &amp;lt;E&amp;gt; Set&amp;lt;E&amp;gt; union(Set&amp;lt;? extends E&amp;gt; s1, Set&amp;lt;? extends E&amp;gt; s2) public static &amp;lt;T extends Comparable&amp;lt;T&amp;gt;&amp;gt; T max(LIst&amp;lt;T&amp;gt; list) // list는 T 객체의 생산자이므로 자료형을 List&amp;lt;? extends T&amp;gt;로 변경 // Comparable는 항상 소비자이므로 &amp;lt;? super T&amp;gt;로 변경 public static &amp;lt;T extends Comparable&amp;lt;? super T&amp;gt;&amp;gt; T max(List&amp;lt;? extends T&amp;gt; list) // 이렇게 고치면 더 광범위하게 사용할 수 있다 List&amp;lt;ScheduledFuture&amp;lt;?&amp;gt;&amp;gt; scheduledFutures = ...; 원래 메서드가 위의 리스트에 적요될 수 없는 것은 ScheduledFuture가 Comparable&amp;lt;ScheduledFuture&amp;gt;를 구현하지 않기 때문이다. ScheduledFuture는 Comparable&amp;lt;Delayed&amp;gt;를 확장하는 Delayed의 하위 인터페이스이다. 다시 말해서, ScheduledFuture 객체는 단순히 다른 ScheduledFuture 객체들하고만 비교할 수 있는 것이 아니다. 어느 Delayed 객체와도 비교가 가능하다. 그래서 수정되기 전의 선언부로는 처리할 수 없는 것이다. 선언부를 수정하고 컴파일하게 되면 아래와 같은 오류가 뜬다. Max.java: incompatible types found: Iterator&amp;lt;capture#591 of ? extends T&amp;gt; required: Iterator&amp;lt;T&amp;gt; Iterator&amp;lt;T&amp;gt; i = list.iterator(); ＾ 이 오류는 list가 List&amp;lt;T&amp;gt;가 아니므로 iterator 메서드가 Iterator&amp;lt;T&amp;gt;를 반환하지 않는다는 뜻이다. 따라서 아래와 같이 내부를 수정하면 된다. public static &amp;lt;T extends Comparable&amp;lt;? super T&amp;gt;&amp;gt; T max(List&amp;lt;? extends T&amp;gt; list) { Iterator&amp;lt;? extends T&amp;gt; i = list.iterator(); T result = i.next(); while (i.hasNext()) { T t = i.next(); if (t.compateTo(result) &amp;gt; 0) { result = t; } } return result; } 반환값에는 와일드카드 자료형을 사용하면 안된다. 좀 더 유연한 코드를 만들 수 있도록 도와주기는커녕, 클라이언트 코드 안에도 와일드카드 자료형을 명시해야 하기 때문이다. 또한, 클래스 사용자가 와일드카드 자료형에 대해 고민하게 된다면, 그것은 아마도 클래스 API가 잘못 설계된 탓일 것이다. 형인자와 와일드카드 사이에 존재하는 이원성 상당수의 메서드를 선언하는 방법에는 두 가지 방법 중 어떤 것으로도 선언될 수 있다는 것이다. swap 메서드를 예제로 들어보자. public static &amp;lt;E&amp;gt; void swap(List&amp;lt;E&amp;gt; list, int i, int j); public static void swap(List&amp;lt;?&amp;gt; list, int i, int j); 두 가지 방법 모두 옳은 방법이지만 public API를 만들고 있다면 두 번째 방법이 더 바람직하다. 형인자를 신경 쓸 필요가 없어져서 더 간단하기 때문이다. 원칙은, 형인자가 메서드 선언에 단 한군데 나타난다면 해당 인자를 와일드카드로 바꾸라는 것이다. 비한정적 형인자이면 비한정적 와일드카드로 바꾸고, 한정적 형인자이면 한정적 와일드카드로 바꾸라. 그런데 형인자 대신 와일드카드를 사용한 swap의 두 번째 선언에는 한 가지 문제가 있다. 당연해 보이는 코드가 컴파일되지 않는 것이다. public static void swap(List&amp;lt;?&amp;gt; list, int i, int j) { list.set(i, list.set(j, list.get(i))); } 다음과 같은 오류가 발생한다. Swap.java: set(int, capture#282 of ?) in List&amp;lt;capture#282 of ?&amp;gt; cannot be aplied to (int,Object) list.set(i, list.set(j, list.get(i))); ＾ 리스트에서 방금 꺼낸 원소를 그 리스트에 다시 넣을 수 없다는 것은 옳지 않아 보인다. 문제는 list의 자료형이 List&amp;lt;?&amp;gt;라는 것이다. List&amp;lt;?&amp;gt;에는 null 이외의 어떤 값도 넣을 수 없다. 다행히도 형 안전성이 보장되지 않는 형변환이나 무인자 자료형을 쓰지 않고도 이 문제를 해겨할 수 있다. private 도움 메서드를 이용해 와일드카드 자료형을 포착하는 것이 기본적인 아이디어이다. 이 도움 메서드는 제네릭 메서드로 정의해야 한다. 그래야 자료형을 포착할 수 있다. public static void swap(List&amp;lt;?&amp;gt; list, int i, int j) // 와일드카드 자료형을 포착하기 위한 private 도움 메서드 private static &amp;lt;E&amp;gt; void swapHelper(List&amp;lt;E&amp;gt; list, int i, int j) { list.set(i, list.set(j, list.get(i))); } swapHelper 메서드는 list가 List&amp;lt;E&amp;gt;라는 것을 안다. 따라서 해당 리스트에서 꺼낸 값의 자료형은 E다. 그리고 E 형의 값은 리스트에 넣어도 안전하다. 조금 복잡해 보이지만 이 코드는 깔끔하게 컴파일된다.">


<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '작성자'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://localhost:4000/"/>





  <title>[Effective Java] 한정적 와일드카드를 써서 API 유연성을 높여라</title>
  
















</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="ko">

  
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Notepad</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            홈
          </a>
        </li>
      
        
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            아카이브
          </a>
        </li>
      
        
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            태그
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

<div id="posts" class="posts-expand">
  
  

  

  
  
  

  <article class="post post-type- " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://localhost:4000/effective%20java/2019/11/07/used-wild-card/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kim BoWoon">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="assets/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Notepad">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
          
          
            [Effective Java] 한정적 와일드카드를 써서 API 유연성을 높여라
          
        </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">작성일</span>
              
              <time title="" itemprop="dateCreated datePublished" datetime="2019-11-07T06:19:42+09:00">
                2019-11-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/category/#/Effective%20Java" itemprop="url" rel="index">
                    <span itemprop="name">Effective Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/effective%20java/2019/11/07/used-wild-card/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="/effective%20java/2019/11/07/used-wild-card/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          
            
                <div class="post-description">
                    
                </div>
            
          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="한정적-와일드카드">한정적 와일드카드</h1>
<p>형인자 자료형은 불변 자료형이다. <code class="language-plaintext highlighter-rouge">List&lt;Object&gt;</code>랑 <code class="language-plaintext highlighter-rouge">List&lt;String&gt;</code>은 같지 않다는 말이다. 직관적으로 이해하기 어렵겠지만 이치에는 맞는 말이다. 때로는 이보다 높은 유연성이 필요할 때가 있다. 전에 만들었던 스택 클래스는 아래와 같은 public API를 갖는다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Stack</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">Stack</span><span class="o">();</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">push</span><span class="o">(</span><span class="no">E</span> <span class="n">e</span><span class="o">);</span>
    <span class="kd">public</span> <span class="no">E</span> <span class="nf">pop</span><span class="o">();</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isEmpty</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>여기에, 일령의 원소들을 인자로 받아 차례로 스택에 집어넣는 메서드를 추가 해보자. 아마 이런 코드를 만들게 될것이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 와일드카드 자료형을 사용하지 않는 pushAll 메서드 - 문제가 있다.</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">pushAll</span><span class="o">(</span><span class="nc">Iterable</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">src</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="no">E</span> <span class="n">e</span> <span class="o">:</span> <span class="n">src</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">push</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>이 메서드는 깔끔하게 컴파일되고 제대로 동작할것같다. 스택이 <code class="language-plaintext highlighter-rouge">Stack&lt;Number&gt;</code>이라고 생각해보자 그러면 Integer 이나 Double이 제대로 들어가고 정상작동할 것이라고 생각한다. 다음 코드 처럼 말이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;</span> <span class="n">numberStack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;();</span>
<span class="nc">Iterable</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">integers</span> <span class="o">=</span> <span class="o">...;</span>
<span class="n">numberStack</span><span class="o">.</span><span class="na">pushAll</span><span class="o">(</span><span class="n">integers</span><span class="o">);</span>
</code></pre></div></div>

<p>하지만 실제로 해 보면 아래와 같은 오류 메시지가 출력된다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">StackTest</span><span class="o">.</span><span class="na">java</span><span class="o">:</span> <span class="n">pushAll</span><span class="o">(</span><span class="nc">Iterable</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;)</span> <span class="n">in</span> <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;</span>
<span class="nc">Cannot</span> <span class="n">be</span> <span class="n">applied</span> <span class="nf">to</span> <span class="o">(</span><span class="nc">Iterable</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;)</span>
<span class="n">numberStack</span><span class="o">.</span><span class="na">pushAll</span><span class="o">(</span><span class="n">integers</span><span class="o">);</span>
           <span class="err">＾</span>
</code></pre></div></div>

<p>형인자 자료형은 불변이기 때문이다. 다행히도 이문제를 해결할 수 있다. 한정적 와일드 카드를 사용하면된다. pushAll의 인자 자료형을 “E의 Iterable”이 아니라 “E의 하위 자료형의 Iterable”이라고 명시하기 위해 <code class="language-plaintext highlighter-rouge">Iterable&lt;? extends E&gt;</code>를 사용한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// E 객체 생산자 역할을 하는 인자에 대한 와일드카드 자료형</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">pushAll</span><span class="o">(</span><span class="nc">Iterable</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">E</span><span class="o">&gt;</span> <span class="n">src</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="no">E</span> <span class="n">e</span> <span class="o">:</span> <span class="n">src</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">push</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>이렇게 만들면 전에 나오던 경고문이 사라질 뿐더러 형안전성이 확보된다. 이와 같이 popAll 메서드도 만들어 보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 와일드카드 자료형 없이 구현한 popAll 메서드 - 문제가 있다.</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">popAll</span><span class="o">(</span><span class="nc">Collection</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">dst</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">while</span> <span class="o">(!</span><span class="n">isEmptu</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">dst</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">pop</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>이 메서드는 깔끔하게 컴파일될 뿐 아니라 인자로 주어진 컬렉션의 원소 자료형이 스택의 원소 자료형과 일치할 때는 완벽히 동작한다. 하지만 스택이 <code class="language-plaintext highlighter-rouge">Stack&lt;Number&gt;</code>이고 Object 형의 변수가 하나 있다고 하자. 스택에서 원소 하나를 꺼내서 해당 변수에 대입하는 코드는 오류 없이 컴파일하고 실행할 수 있다. 그렇다면 아래와 같은 코드도 만들 수 있어야 하지 않을까?</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;</span> <span class="n">numberStack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;();</span>
<span class="nc">Collection</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="n">objects</span> <span class="o">=</span> <span class="o">...;</span>
<span class="n">numberStack</span><span class="o">.</span><span class="na">popAll</span><span class="o">(</span><span class="n">objects</span><span class="o">);</span>
</code></pre></div></div>

<p>이 코드를 컴파일 해보면 pushAll 메서드에서 발생한 오류와 비슷한 오류가 발생한다. <code class="language-plaintext highlighter-rouge">Collection&lt;Object&gt;</code>가 <code class="language-plaintext highlighter-rouge">Collection&lt;Number&gt;</code>의 하위 자료형이 아니라는 오류가 난다는 것이다. 이 문제도 와일드카드 자료형을 쓰면 극복할 수 있다. popAll의 인자 자료형을 “E의 컬렉션”이 아니라 “E의 상위 자료형의 컬렉션”이라고 명시하는 것이다. 그러면 다음과 같이 코드를 수정해보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// E의 소비자 구실을 하는 인자에 대한 와일드카드 자료형</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">popAll</span><span class="o">(</span><span class="nc">Collection</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">E</span><span class="o">&gt;</span> <span class="n">dst</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">while</span> <span class="o">(!</span><span class="n">isEmpty</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">dst</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">pop</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>이렇게 바꾸면 Stack과 클라이언트 코드는 깔끔하게 컴파일된다. 유연성을 최대화 하려면 객체 생산자나 소비자 구실을 하는 메서드 인자의 자료형은 와일드카드 자료형으로 하라는 것이다. 이 때, 어떤 와일드카드 자료형을 쓸지 모르겠다면 다음을 참고하자.</p>

<p>PECS (Produce - Extends, Consumer - Super)</p>

<p>그러니까, 인자가 T 생산자라면 &lt;? extends T&gt;라고 하고 T 소비자라면 &lt;? super T&gt;라고 하라는 것이다. 연습으로 전에 만들었던 메서드들에 적용 시켜보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="nf">reduce</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">,</span> <span class="nc">FUnction</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">,</span> <span class="no">E</span> <span class="n">initVal</span><span class="o">)</span>

<span class="cm">/*
list 인자를 E 생산자로만 사용하므로 와일드카드 자료형 "? extends E"로 선언
f는 생산자와 소비자가 동일하기 때문에 와일드카드 자료형을 사용하면 안된다.
*/</span>
<span class="c1">// E 생산자 구실을 하는 인자에 와일드카드 자료형 적용</span>
<span class="kd">static</span> <span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="no">E</span> <span class="nf">reduce</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">E</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">,</span> <span class="nc">Function</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">,</span> <span class="no">E</span> <span class="n">initVal</span><span class="o">)</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="nf">union</span><span class="o">(</span><span class="nc">Set</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">s1</span><span class="o">,</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">s2</span><span class="o">)</span>

<span class="c1">// 인자 모두가 전부 생산자 이므로 다음과 같이 고쳐진다.</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="nf">union</span><span class="o">(</span><span class="nc">Set</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">E</span><span class="o">&gt;</span> <span class="n">s1</span><span class="o">,</span> <span class="nc">Set</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">E</span><span class="o">&gt;</span> <span class="n">s2</span><span class="o">)</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span> <span class="kd">extends</span> <span class="nc">Comparable</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;&gt;</span> <span class="no">T</span> <span class="nf">max</span><span class="o">(</span><span class="nc">LIst</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">)</span>

<span class="c1">// list는 T 객체의 생산자이므로 자료형을 List&lt;? extends T&gt;로 변경</span>
<span class="c1">// Comparable는 항상 소비자이므로 &lt;? super T&gt;로 변경</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span> <span class="kd">extends</span> <span class="nc">Comparable</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">&gt;&gt;</span> <span class="no">T</span> <span class="nf">max</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">T</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">)</span>

<span class="c1">// 이렇게 고치면 더 광범위하게 사용할 수 있다</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">ScheduledFuture</span><span class="o">&lt;?&gt;&gt;</span> <span class="n">scheduledFutures</span> <span class="o">=</span> <span class="o">...;</span>
</code></pre></div></div>

<p>원래 메서드가 위의 리스트에 적요될 수 없는 것은 ScheduledFuture가 <code class="language-plaintext highlighter-rouge">Comparable&lt;ScheduledFuture&gt;</code>를 구현하지 않기 때문이다. ScheduledFuture는 <code class="language-plaintext highlighter-rouge">Comparable&lt;Delayed&gt;</code>를 확장하는 Delayed의 하위 인터페이스이다. 다시 말해서, ScheduledFuture 객체는 단순히 다른 ScheduledFuture 객체들하고만 비교할 수 있는 것이 아니다. 어느 Delayed 객체와도 비교가 가능하다. 그래서 수정되기 전의 선언부로는 처리할 수 없는 것이다.</p>

<p>선언부를 수정하고 컴파일하게 되면 아래와 같은 오류가 뜬다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Max</span><span class="o">.</span><span class="na">java</span><span class="o">:</span> <span class="n">incompatible</span> <span class="n">types</span>
<span class="nl">found:</span> <span class="nc">Iterator</span><span class="o">&lt;</span><span class="n">capture</span><span class="err">#</span><span class="mi">591</span> <span class="n">of</span> <span class="o">?</span> <span class="kd">extends</span> <span class="no">T</span><span class="o">&gt;</span>
<span class="nl">required:</span> <span class="nc">Iterator</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span>
<span class="nc">Iterator</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span>
                             <span class="err">＾</span>
</code></pre></div></div>

<p>이 오류는 list가 <code class="language-plaintext highlighter-rouge">List&lt;T&gt;</code>가 아니므로 iterator 메서드가 <code class="language-plaintext highlighter-rouge">Iterator&lt;T&gt;</code>를 반환하지 않는다는 뜻이다. 따라서 아래와 같이 내부를 수정하면 된다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span> <span class="kd">extends</span> <span class="nc">Comparable</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">&gt;&gt;</span> <span class="no">T</span> <span class="nf">max</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">T</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Iterator</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">T</span><span class="o">&gt;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span>
    <span class="no">T</span> <span class="n">result</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">i</span><span class="o">.</span><span class="na">hasNext</span><span class="o">())</span> <span class="o">{</span>
        <span class="no">T</span> <span class="n">t</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">compateTo</span><span class="o">(</span><span class="n">result</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>반환값에는 와일드카드 자료형을 사용하면 안된다. 좀 더 유연한 코드를 만들 수 있도록 도와주기는커녕, 클라이언트 코드 안에도 와일드카드 자료형을 명시해야 하기 때문이다. 또한, 클래스 사용자가 와일드카드 자료형에 대해 고민하게 된다면, 그것은 아마도 클래스 API가 잘못 설계된 탓일 것이다.</p>

<h1 id="형인자와-와일드카드-사이에-존재하는-이원성">형인자와 와일드카드 사이에 존재하는 이원성</h1>
<p>상당수의 메서드를 선언하는 방법에는 두 가지 방법 중 어떤 것으로도 선언될 수 있다는 것이다. swap 메서드를 예제로 들어보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">swap</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">);</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">swap</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;?&gt;</span> <span class="n">list</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">);</span>
</code></pre></div></div>

<p>두 가지 방법 모두 옳은 방법이지만 public API를 만들고 있다면 두 번째 방법이 더 바람직하다. 형인자를 신경 쓸 필요가 없어져서 더 간단하기 때문이다. 원칙은, 형인자가 메서드 선언에 단 한군데 나타난다면 해당 인자를 와일드카드로 바꾸라는 것이다. 비한정적 형인자이면 비한정적 와일드카드로 바꾸고, 한정적 형인자이면 한정적 와일드카드로 바꾸라.</p>

<p>그런데 형인자 대신 와일드카드를 사용한 swap의 두 번째 선언에는 한 가지 문제가 있다. 당연해 보이는 코드가 컴파일되지 않는 것이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">swap</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;?&gt;</span> <span class="n">list</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">list</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">list</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">j</span><span class="o">,</span> <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">)));</span>
<span class="o">}</span>
</code></pre></div></div>

<p>다음과 같은 오류가 발생한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Swap</span><span class="o">.</span><span class="na">java</span><span class="o">:</span> <span class="n">set</span><span class="o">(</span><span class="kt">int</span><span class="o">,</span> <span class="n">capture</span><span class="err">#</span><span class="mi">282</span> <span class="n">of</span> <span class="o">?)</span> <span class="n">in</span> <span class="nc">List</span><span class="o">&lt;</span><span class="n">capture</span><span class="err">#</span><span class="mi">282</span> <span class="n">of</span> <span class="o">?&gt;</span>
<span class="n">cannot</span> <span class="n">be</span> <span class="n">aplied</span> <span class="nf">to</span> <span class="o">(</span><span class="kt">int</span><span class="o">,</span><span class="nc">Object</span><span class="o">)</span>
<span class="n">list</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">list</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">j</span><span class="o">,</span> <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">)));</span>
                <span class="err">＾</span>
</code></pre></div></div>

<p>리스트에서 방금 꺼낸 원소를 그 리스트에 다시 넣을 수 없다는 것은 옳지 않아 보인다. 문제는 list의 자료형이 <code class="language-plaintext highlighter-rouge">List&lt;?&gt;</code>라는 것이다. <code class="language-plaintext highlighter-rouge">List&lt;?&gt;</code>에는 null 이외의 어떤 값도 넣을 수 없다. 다행히도 형 안전성이 보장되지 않는 형변환이나 무인자 자료형을 쓰지 않고도 이 문제를 해겨할 수 있다. private 도움 메서드를 이용해 와일드카드 자료형을 포착하는 것이 기본적인 아이디어이다. 이 도움 메서드는 제네릭 메서드로 정의해야 한다. 그래야 자료형을 포착할 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">swap</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;?&gt;</span> <span class="n">list</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">)</span>

<span class="c1">// 와일드카드 자료형을 포착하기 위한 private 도움 메서드</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">swapHelper</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">list</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">list</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">j</span><span class="o">,</span> <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">)));</span>
<span class="o">}</span>
</code></pre></div></div>

<p>swapHelper 메서드는 list가 <code class="language-plaintext highlighter-rouge">List&lt;E&gt;</code>라는 것을 안다. 따라서 해당 리스트에서 꺼낸 값의 자료형은 E다. 그리고 E 형의 값은 리스트에 넣어도 안전하다. 조금 복잡해 보이지만 이 코드는 깔끔하게 컴파일된다.</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
      
      
      
      

      
      
        <div class="post-nav" id="post-nav-id">
          <div class="post-nav-next post-nav-item">
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/effective%20java/2019/11/05/used-generic-method/" rel="prev" title="[Effective Java] 가능하면 제네릭 메서드로 만들 것">
                [Effective Java] 가능하면 제네릭 메서드로 만들 것 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      
      

      
    </footer>
  </article>

  <div class="post-spread">
    
  </div>
</div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          

  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      
        
        
        




      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            목차
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            흝어보기
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/assets/images/avatar.gif"
               alt="Kim BoWoon" />
          <p class="site-author-name" itemprop="name">Kim BoWoon</p>
           
              <p class="site-description motion-element" itemprop="description">https://kimbowoon.github.io/</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">38</span>
                <span class="site-state-item-name">포스트</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">카테고리</span>
              </a>
            </div>
          

          

        </nav>

        
        
        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            





            
              <div class="post-toc-content">
    <ol class=nav>
      <li class="nav-item nav-level-1"> <a class="nav-link" href="#한정적-와일드카드"> <span class="nav-number">1</span> <span class="nav-text">한정적 와일드카드</span> </a> <ol class="nav-child"> <ol class="nav-child"> <ol class="nav-child"> <ol class="nav-child"> <ol class="nav-child"> </li></ol> </li></ol> </li></ol> </li></ol> </li></ol> </li> <li class="nav-item nav-level-1"> <a class="nav-link" href="#형인자와-와일드카드-사이에-존재하는-이원성"> <span class="nav-number">2</span> <span class="nav-text">형인자와 와일드카드 사이에 존재하는 이원성</span> </a> <ol class="nav-child"> <ol class="nav-child"> <ol class="nav-child"> <ol class="nav-child"> <ol class="nav-child">
    </ol>
  </div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>

        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Kim BoWoon</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://jekyllrb.com">Jekyll</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/simpleyyt/jekyll-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>





















  
   
  
  
  
  
  
  <script type="text/javascript" src="/assets/lib/jquery/index.js?v=2.1.3"></script>

  
  
  
  
  
  <script type="text/javascript" src="/assets/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  
  
  
  
  <script type="text/javascript" src="/assets/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  
  
  
  
  <script type="text/javascript" src="/assets/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  
  
  
  
  <script type="text/javascript" src="/assets/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  
  
  
  
  <script type="text/javascript" src="/assets/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/assets/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/assets/js/src/motion.js?v=5.1.1"></script>



  
  

  <script type="text/javascript" src="/assets/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/assets/js/src/post-details.js?v=5.1.1"></script>


  


  <script type="text/javascript" src="/assets/js/src/bootstrap.js?v=5.1.1"></script>



  


  

    
      <script id="dsq-count-scr" src="https://kimbowoon.disqus.com/count.js" async></script>
    

    
      
      <script type="text/javascript">
          var disqus_config = function () {
              this.page.url = 'http://localhost:4000/effective%20java/2019/11/07/used-wild-card/';
              this.page.identifier = '/effective%20java/2019/11/07/used-wild-card/';
              this.page.title = '[Effective Java] 한정적 와일드카드를 써서 API 유연성을 높여라';
          };
          var d = document, s = d.createElement('script');
          s.src = 'https://kimbowoon.disqus.com/embed.js';
          s.setAttribute('data-timestamp', '' + +new Date());
          (d.head || d.body).appendChild(s);
      </script>
      
    

  




	





  





  




  





  






  

  

  
  


  

  

  

</body>
</html>

