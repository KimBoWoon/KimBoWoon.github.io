
<!doctype html>














<html class="theme-next muse use-motion" lang="ko">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/assets/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/assets/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/assets/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="" />





  <link rel="alternate" href="/atom.xml" title="Notepad" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/assets/favicon.ico?v=5.1.1" />
















<meta name="description" content="배열과 제네릭의 차이 첫번째로는 배열은 공변 자료형이다. Sub가 Super의 하위 자료형 이라면 Sub[]도 Super[]의 하위 자료형이라는 것이다. 반면에 제네릭은 불변 자료형이다. Type1과 Type2가 있을 때 List&amp;lt;Type1&amp;gt;은 List&amp;lt;Type2&amp;gt;의 상위 자료형이나 하위 자료형이 될 수 없다. 아래의 코드를 보자 // 실행중에 문제를 일으킴 Object[] objectArray = new Long[1]; objectArray[0] = &quot;I don&apos;t fit in&quot;; 하지만 아래의 코드는 컴파일 조차 안된다. List&amp;lt;Object&amp;gt; ol = new ArrayList&amp;lt;Long&amp;gt;; // 자료형 불일치 ol.add(&quot;I don&apos;t fit in&quot;); 둘 중 어떤 방법을 써도 Long 객체 컨터이너 안에 String을 넣을 수 없다. 그러나 배열을 쓰면 실수를 저지른 사실을 프로그램 실행 중에나 알 수 있다. 두번째로는 배열은 실체화 되는 자료형이라는 것이다. 즉, 배열의 각 원소의 자료형은 실행시간에 결정된다는 것이다. 반면 제네릭은 삭제 과정을 통해 구현된다. 즉, 자료형에 관계된 조건들은 컴파일 시점에만 적용되고, 그 각 원소의 자료형 정보는 프로그램이 실행될 때는 삭제된다는 것이다. 이러한 차이점 때문에 배열과 제네릭은 섞어 쓰기 어렵다. List&amp;lt;String&amp;gt;[], new E[] 와 같은 것을 만들려고 하면 제네릭 배열 생성이라는 오류가 발생한다. 제네릭 배열이 생성되지 않는 이유는 형 안전성이 보장되지 않기 때문이다. 아래의 코드를 보자. // 제네릭 배열 생성이 허용되지 않는 이유 - 아래의 코드는 컴파일되지 않는다! List&amp;lt;String&amp;gt;[] stringLists = new List&amp;lt;String&amp;gt;[1]; // (1) List&amp;lt;Integer&amp;gt; intList = Arrays.asList(42); // (2) Object[] objects = stringLists; // (3) objects[0] = intList; // (4) String s = stringLists[0].get(0); // (5) (1)이 문제없이 컴파일이 된다면, 제네릭 배열이 만들어질 것이다. (2)는 하나의 원소를 갖는 배열 List&amp;lt;Integer&amp;gt;를 초기화한다. (3)은 List&amp;lt;String&amp;gt; 배열을 Object 배열 변수에 대입한다. 배열은 공변 자료형이므로, 가능하다. (4) 에서는 List&amp;lt;Integer&amp;gt;를 Object 배열에 있는 유일한 원소에 대입한다. 제네릭이 형 삭제를 통해 구현되므로 여기에도 하자는 없다. 하지만 List&amp;lt;String&amp;gt;만 들어간다고 만들어둔 배열에 List&amp;lt;Integer&amp;gt;을 저장한것이다. (5)에서는 저장된 원소를 꺼내는 작업을 하는데 사실을 Integer값을 꺼내서 String으로 변환하려는 것이다. 그래서 ClassCastException이 발생한다. 그래서 컴파일러는 (1)에서 오류를 발생시키는 것이다. List&amp;lt;E&amp;gt;는 성능이 저하되거나 코드가 길어질 수는 있겠으나, 형 안전성과 호환성은 좋아진다. 예를 들어, 동기화된 리스트가 하나 있고 리스트에 원소의 자료형과 같은 자료형의 값 두 개를 인자로 받는 함수가 하나 있다고 하자. 이 함수는 리스트의 원소가 정수면 모두 더하거나 곱하고, 문자열이면 모든 문자열 연결하여 반환하는 함수이다. 이렇게 리스트를 줄이는 것이다. 이러한 함수를 제네릭 없이 작성한다면 아래와 같은 모습일 것이다. static Object reduce(List list, Function f, Object initVal) { synchronized(list) { Object result = initVal; for (Object o : list) { result = f.apply(result, o); } return result; } } interface Function { Object apply(Object artg1, Object arg2); } 동기화 영역 안에서는 “불가해 메서드”를 호출하면 안된다. 그러니 락을 건 상태에서 리스트를 복사한 다음, 복사본에 작업하도록 메서드를 수정해야 한다. 1.5 이전의 자바에서는 List의 toArray 메서드를 사용한다. 내부적으로 리스트에 락을 걸기 때문이다. // 제네릭 없이 작성한 reduce 함수. 병행성 문제는 없다. static Object reduce(List list, Function f, Object initVal) { Object[] snapshot = list.toArray(); // 리스트에 내부적으로 락을 건다 Object result = initVal; for (Object o : list) { result = f.apply(result, o); } return result; } 이런 작업을 제네릭으로 하게 되면 앞서 말한 문제들을 만나게 된다. Function 인터페이스와 reduce 메서드를 제네릭 버전으로 바꿔보자. static &amp;lt;E&amp;gt; E reduce(List&amp;lt;E&amp;gt; list, Function&amp;lt;E&amp;gt; f, E initVal) { E[] snapshot = list.toArray(); // 리스트에 내부적으로 락을 건다 E result = initVal; for (E e : list) { result = f.apply(result, e); } return result; } interface Function&amp;lt;T&amp;gt; { T apply(T arg1, T arg2); } 이렇게 만들고 컴파일하면 오류를가 발생한다. Practice.java: incompatible types found : Object[], required: E[] E[] snapshot = list.toArray(); // 리스트에 락을 건다 ＾ Object 배열을 E 배열로 형변환 하면 OK 아닌가? 라고 생각할 수 있지만 그러면 새로운 경고가 뜬다. Practice.java: warning: [unchecked] unchecked cast found : Object[], required: E[] E[] snapshot = list.toArray(); // 리스트에 락을 건다 ＾ 컴파일러는 실행 도중에 형변환이 안전하게 이루어질지 검사할 수 없다는 뜻이다. 실행 시에 E가 무슨 자료형이 될지 알 수 없기 때문이다. 원소의 자료형 정보는 프로그램이 실행될 때에는 제네릭에서 삭제된다. 그렇다면 어떻게 만들어야 할까? 단순하다 배열 대신 리스트를 사용하면 된다. static &amp;lt;E&amp;gt; E reduce(List&amp;lt;E&amp;gt; list, Function&amp;lt;E&amp;gt; f, E initVal) { List&amp;lt;E&amp;gt; snapshot; synchronized(list) { snapshot = new ArrayList&amp;lt;E&amp;gt;(list); } E result = initVal; for (E e : list) { result = f.apply(result, e); } return result; } interface Function&amp;lt;T&amp;gt; { T apply(T arg1, T arg2); } 앞에 나왔던 코드들 보다 길지만, 실행 도중에 ClassCastException이 발생할 일이 없으므로 그만한 값어치가 있다.">
<meta name="keywords" content="Jekyll, NexT">
<meta property="og:type" content="article">
<meta property="og:title" content="[Effective Java] 배열 대신 리스트를 써라">
<meta property="og:url" content="http://localhost:4000/effective%20java/2019/11/02/not-array-used-List/">
<meta property="og:site_name" content="Notepad">
<meta property="og:description" content="배열과 제네릭의 차이 첫번째로는 배열은 공변 자료형이다. Sub가 Super의 하위 자료형 이라면 Sub[]도 Super[]의 하위 자료형이라는 것이다. 반면에 제네릭은 불변 자료형이다. Type1과 Type2가 있을 때 List&amp;lt;Type1&amp;gt;은 List&amp;lt;Type2&amp;gt;의 상위 자료형이나 하위 자료형이 될 수 없다. 아래의 코드를 보자 // 실행중에 문제를 일으킴 Object[] objectArray = new Long[1]; objectArray[0] = &quot;I don&apos;t fit in&quot;; 하지만 아래의 코드는 컴파일 조차 안된다. List&amp;lt;Object&amp;gt; ol = new ArrayList&amp;lt;Long&amp;gt;; // 자료형 불일치 ol.add(&quot;I don&apos;t fit in&quot;); 둘 중 어떤 방법을 써도 Long 객체 컨터이너 안에 String을 넣을 수 없다. 그러나 배열을 쓰면 실수를 저지른 사실을 프로그램 실행 중에나 알 수 있다. 두번째로는 배열은 실체화 되는 자료형이라는 것이다. 즉, 배열의 각 원소의 자료형은 실행시간에 결정된다는 것이다. 반면 제네릭은 삭제 과정을 통해 구현된다. 즉, 자료형에 관계된 조건들은 컴파일 시점에만 적용되고, 그 각 원소의 자료형 정보는 프로그램이 실행될 때는 삭제된다는 것이다. 이러한 차이점 때문에 배열과 제네릭은 섞어 쓰기 어렵다. List&amp;lt;String&amp;gt;[], new E[] 와 같은 것을 만들려고 하면 제네릭 배열 생성이라는 오류가 발생한다. 제네릭 배열이 생성되지 않는 이유는 형 안전성이 보장되지 않기 때문이다. 아래의 코드를 보자. // 제네릭 배열 생성이 허용되지 않는 이유 - 아래의 코드는 컴파일되지 않는다! List&amp;lt;String&amp;gt;[] stringLists = new List&amp;lt;String&amp;gt;[1]; // (1) List&amp;lt;Integer&amp;gt; intList = Arrays.asList(42); // (2) Object[] objects = stringLists; // (3) objects[0] = intList; // (4) String s = stringLists[0].get(0); // (5) (1)이 문제없이 컴파일이 된다면, 제네릭 배열이 만들어질 것이다. (2)는 하나의 원소를 갖는 배열 List&amp;lt;Integer&amp;gt;를 초기화한다. (3)은 List&amp;lt;String&amp;gt; 배열을 Object 배열 변수에 대입한다. 배열은 공변 자료형이므로, 가능하다. (4) 에서는 List&amp;lt;Integer&amp;gt;를 Object 배열에 있는 유일한 원소에 대입한다. 제네릭이 형 삭제를 통해 구현되므로 여기에도 하자는 없다. 하지만 List&amp;lt;String&amp;gt;만 들어간다고 만들어둔 배열에 List&amp;lt;Integer&amp;gt;을 저장한것이다. (5)에서는 저장된 원소를 꺼내는 작업을 하는데 사실을 Integer값을 꺼내서 String으로 변환하려는 것이다. 그래서 ClassCastException이 발생한다. 그래서 컴파일러는 (1)에서 오류를 발생시키는 것이다. List&amp;lt;E&amp;gt;는 성능이 저하되거나 코드가 길어질 수는 있겠으나, 형 안전성과 호환성은 좋아진다. 예를 들어, 동기화된 리스트가 하나 있고 리스트에 원소의 자료형과 같은 자료형의 값 두 개를 인자로 받는 함수가 하나 있다고 하자. 이 함수는 리스트의 원소가 정수면 모두 더하거나 곱하고, 문자열이면 모든 문자열 연결하여 반환하는 함수이다. 이렇게 리스트를 줄이는 것이다. 이러한 함수를 제네릭 없이 작성한다면 아래와 같은 모습일 것이다. static Object reduce(List list, Function f, Object initVal) { synchronized(list) { Object result = initVal; for (Object o : list) { result = f.apply(result, o); } return result; } } interface Function { Object apply(Object artg1, Object arg2); } 동기화 영역 안에서는 “불가해 메서드”를 호출하면 안된다. 그러니 락을 건 상태에서 리스트를 복사한 다음, 복사본에 작업하도록 메서드를 수정해야 한다. 1.5 이전의 자바에서는 List의 toArray 메서드를 사용한다. 내부적으로 리스트에 락을 걸기 때문이다. // 제네릭 없이 작성한 reduce 함수. 병행성 문제는 없다. static Object reduce(List list, Function f, Object initVal) { Object[] snapshot = list.toArray(); // 리스트에 내부적으로 락을 건다 Object result = initVal; for (Object o : list) { result = f.apply(result, o); } return result; } 이런 작업을 제네릭으로 하게 되면 앞서 말한 문제들을 만나게 된다. Function 인터페이스와 reduce 메서드를 제네릭 버전으로 바꿔보자. static &amp;lt;E&amp;gt; E reduce(List&amp;lt;E&amp;gt; list, Function&amp;lt;E&amp;gt; f, E initVal) { E[] snapshot = list.toArray(); // 리스트에 내부적으로 락을 건다 E result = initVal; for (E e : list) { result = f.apply(result, e); } return result; } interface Function&amp;lt;T&amp;gt; { T apply(T arg1, T arg2); } 이렇게 만들고 컴파일하면 오류를가 발생한다. Practice.java: incompatible types found : Object[], required: E[] E[] snapshot = list.toArray(); // 리스트에 락을 건다 ＾ Object 배열을 E 배열로 형변환 하면 OK 아닌가? 라고 생각할 수 있지만 그러면 새로운 경고가 뜬다. Practice.java: warning: [unchecked] unchecked cast found : Object[], required: E[] E[] snapshot = list.toArray(); // 리스트에 락을 건다 ＾ 컴파일러는 실행 도중에 형변환이 안전하게 이루어질지 검사할 수 없다는 뜻이다. 실행 시에 E가 무슨 자료형이 될지 알 수 없기 때문이다. 원소의 자료형 정보는 프로그램이 실행될 때에는 제네릭에서 삭제된다. 그렇다면 어떻게 만들어야 할까? 단순하다 배열 대신 리스트를 사용하면 된다. static &amp;lt;E&amp;gt; E reduce(List&amp;lt;E&amp;gt; list, Function&amp;lt;E&amp;gt; f, E initVal) { List&amp;lt;E&amp;gt; snapshot; synchronized(list) { snapshot = new ArrayList&amp;lt;E&amp;gt;(list); } E result = initVal; for (E e : list) { result = f.apply(result, e); } return result; } interface Function&amp;lt;T&amp;gt; { T apply(T arg1, T arg2); } 앞에 나왔던 코드들 보다 길지만, 실행 도중에 ClassCastException이 발생할 일이 없으므로 그만한 값어치가 있다.">
<meta property="og:locale" content="ko">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="[Effective Java] 배열 대신 리스트를 써라">
<meta name="twitter:description" content="배열과 제네릭의 차이 첫번째로는 배열은 공변 자료형이다. Sub가 Super의 하위 자료형 이라면 Sub[]도 Super[]의 하위 자료형이라는 것이다. 반면에 제네릭은 불변 자료형이다. Type1과 Type2가 있을 때 List&amp;lt;Type1&amp;gt;은 List&amp;lt;Type2&amp;gt;의 상위 자료형이나 하위 자료형이 될 수 없다. 아래의 코드를 보자 // 실행중에 문제를 일으킴 Object[] objectArray = new Long[1]; objectArray[0] = &quot;I don&apos;t fit in&quot;; 하지만 아래의 코드는 컴파일 조차 안된다. List&amp;lt;Object&amp;gt; ol = new ArrayList&amp;lt;Long&amp;gt;; // 자료형 불일치 ol.add(&quot;I don&apos;t fit in&quot;); 둘 중 어떤 방법을 써도 Long 객체 컨터이너 안에 String을 넣을 수 없다. 그러나 배열을 쓰면 실수를 저지른 사실을 프로그램 실행 중에나 알 수 있다. 두번째로는 배열은 실체화 되는 자료형이라는 것이다. 즉, 배열의 각 원소의 자료형은 실행시간에 결정된다는 것이다. 반면 제네릭은 삭제 과정을 통해 구현된다. 즉, 자료형에 관계된 조건들은 컴파일 시점에만 적용되고, 그 각 원소의 자료형 정보는 프로그램이 실행될 때는 삭제된다는 것이다. 이러한 차이점 때문에 배열과 제네릭은 섞어 쓰기 어렵다. List&amp;lt;String&amp;gt;[], new E[] 와 같은 것을 만들려고 하면 제네릭 배열 생성이라는 오류가 발생한다. 제네릭 배열이 생성되지 않는 이유는 형 안전성이 보장되지 않기 때문이다. 아래의 코드를 보자. // 제네릭 배열 생성이 허용되지 않는 이유 - 아래의 코드는 컴파일되지 않는다! List&amp;lt;String&amp;gt;[] stringLists = new List&amp;lt;String&amp;gt;[1]; // (1) List&amp;lt;Integer&amp;gt; intList = Arrays.asList(42); // (2) Object[] objects = stringLists; // (3) objects[0] = intList; // (4) String s = stringLists[0].get(0); // (5) (1)이 문제없이 컴파일이 된다면, 제네릭 배열이 만들어질 것이다. (2)는 하나의 원소를 갖는 배열 List&amp;lt;Integer&amp;gt;를 초기화한다. (3)은 List&amp;lt;String&amp;gt; 배열을 Object 배열 변수에 대입한다. 배열은 공변 자료형이므로, 가능하다. (4) 에서는 List&amp;lt;Integer&amp;gt;를 Object 배열에 있는 유일한 원소에 대입한다. 제네릭이 형 삭제를 통해 구현되므로 여기에도 하자는 없다. 하지만 List&amp;lt;String&amp;gt;만 들어간다고 만들어둔 배열에 List&amp;lt;Integer&amp;gt;을 저장한것이다. (5)에서는 저장된 원소를 꺼내는 작업을 하는데 사실을 Integer값을 꺼내서 String으로 변환하려는 것이다. 그래서 ClassCastException이 발생한다. 그래서 컴파일러는 (1)에서 오류를 발생시키는 것이다. List&amp;lt;E&amp;gt;는 성능이 저하되거나 코드가 길어질 수는 있겠으나, 형 안전성과 호환성은 좋아진다. 예를 들어, 동기화된 리스트가 하나 있고 리스트에 원소의 자료형과 같은 자료형의 값 두 개를 인자로 받는 함수가 하나 있다고 하자. 이 함수는 리스트의 원소가 정수면 모두 더하거나 곱하고, 문자열이면 모든 문자열 연결하여 반환하는 함수이다. 이렇게 리스트를 줄이는 것이다. 이러한 함수를 제네릭 없이 작성한다면 아래와 같은 모습일 것이다. static Object reduce(List list, Function f, Object initVal) { synchronized(list) { Object result = initVal; for (Object o : list) { result = f.apply(result, o); } return result; } } interface Function { Object apply(Object artg1, Object arg2); } 동기화 영역 안에서는 “불가해 메서드”를 호출하면 안된다. 그러니 락을 건 상태에서 리스트를 복사한 다음, 복사본에 작업하도록 메서드를 수정해야 한다. 1.5 이전의 자바에서는 List의 toArray 메서드를 사용한다. 내부적으로 리스트에 락을 걸기 때문이다. // 제네릭 없이 작성한 reduce 함수. 병행성 문제는 없다. static Object reduce(List list, Function f, Object initVal) { Object[] snapshot = list.toArray(); // 리스트에 내부적으로 락을 건다 Object result = initVal; for (Object o : list) { result = f.apply(result, o); } return result; } 이런 작업을 제네릭으로 하게 되면 앞서 말한 문제들을 만나게 된다. Function 인터페이스와 reduce 메서드를 제네릭 버전으로 바꿔보자. static &amp;lt;E&amp;gt; E reduce(List&amp;lt;E&amp;gt; list, Function&amp;lt;E&amp;gt; f, E initVal) { E[] snapshot = list.toArray(); // 리스트에 내부적으로 락을 건다 E result = initVal; for (E e : list) { result = f.apply(result, e); } return result; } interface Function&amp;lt;T&amp;gt; { T apply(T arg1, T arg2); } 이렇게 만들고 컴파일하면 오류를가 발생한다. Practice.java: incompatible types found : Object[], required: E[] E[] snapshot = list.toArray(); // 리스트에 락을 건다 ＾ Object 배열을 E 배열로 형변환 하면 OK 아닌가? 라고 생각할 수 있지만 그러면 새로운 경고가 뜬다. Practice.java: warning: [unchecked] unchecked cast found : Object[], required: E[] E[] snapshot = list.toArray(); // 리스트에 락을 건다 ＾ 컴파일러는 실행 도중에 형변환이 안전하게 이루어질지 검사할 수 없다는 뜻이다. 실행 시에 E가 무슨 자료형이 될지 알 수 없기 때문이다. 원소의 자료형 정보는 프로그램이 실행될 때에는 제네릭에서 삭제된다. 그렇다면 어떻게 만들어야 할까? 단순하다 배열 대신 리스트를 사용하면 된다. static &amp;lt;E&amp;gt; E reduce(List&amp;lt;E&amp;gt; list, Function&amp;lt;E&amp;gt; f, E initVal) { List&amp;lt;E&amp;gt; snapshot; synchronized(list) { snapshot = new ArrayList&amp;lt;E&amp;gt;(list); } E result = initVal; for (E e : list) { result = f.apply(result, e); } return result; } interface Function&amp;lt;T&amp;gt; { T apply(T arg1, T arg2); } 앞에 나왔던 코드들 보다 길지만, 실행 도중에 ClassCastException이 발생할 일이 없으므로 그만한 값어치가 있다.">


<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '작성자'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://localhost:4000/"/>





  <title>[Effective Java] 배열 대신 리스트를 써라</title>
  
















</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="ko">

  
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Notepad</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            홈
          </a>
        </li>
      
        
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            아카이브
          </a>
        </li>
      
        
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            태그
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

<div id="posts" class="posts-expand">
  
  

  

  
  
  

  <article class="post post-type- " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://localhost:4000/effective%20java/2019/11/02/not-array-used-List/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kim BoWoon">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="assets/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Notepad">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
          
          
            [Effective Java] 배열 대신 리스트를 써라
          
        </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">작성일</span>
              
              <time title="" itemprop="dateCreated datePublished" datetime="2019-11-02T08:19:42+09:00">
                2019-11-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/category/#/Effective%20Java" itemprop="url" rel="index">
                    <span itemprop="name">Effective Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/effective%20java/2019/11/02/not-array-used-List/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="/effective%20java/2019/11/02/not-array-used-List/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          
            
                <div class="post-description">
                    
                </div>
            
          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="배열과-제네릭의-차이">배열과 제네릭의 차이</h1>
<p>첫번째로는 배열은 공변 자료형이다. Sub가 Super의 하위 자료형 이라면 Sub[]도 Super[]의 하위 자료형이라는 것이다. 반면에 제네릭은 불변 자료형이다. Type1과 Type2가 있을 때 <code class="language-plaintext highlighter-rouge">List&lt;Type1&gt;</code>은 <code class="language-plaintext highlighter-rouge">List&lt;Type2&gt;</code>의 상위 자료형이나 하위 자료형이 될 수 없다. 아래의 코드를 보자</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 실행중에 문제를 일으킴</span>
<span class="nc">Object</span><span class="o">[]</span> <span class="n">objectArray</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Long</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
<span class="n">objectArray</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="s">"I don't fit in"</span><span class="o">;</span>
</code></pre></div></div>

<p>하지만 아래의 코드는 컴파일 조차 안된다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="n">ol</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;;</span> <span class="c1">// 자료형 불일치</span>
<span class="n">ol</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"I don't fit in"</span><span class="o">);</span>
</code></pre></div></div>

<p>둘 중 어떤 방법을 써도 Long 객체 컨터이너 안에 String을 넣을 수 없다. 그러나 배열을 쓰면 실수를 저지른 사실을 프로그램 실행 중에나 알 수 있다.</p>

<p>두번째로는 배열은 실체화 되는 자료형이라는 것이다. 즉, 배열의 각 원소의 자료형은 실행시간에 결정된다는 것이다. 반면 제네릭은 삭제 과정을 통해 구현된다. 즉, 자료형에 관계된 조건들은 컴파일 시점에만 적용되고, 그 각 원소의 자료형 정보는 프로그램이 실행될 때는 삭제된다는 것이다.</p>

<p>이러한 차이점 때문에 배열과 제네릭은 섞어 쓰기 어렵다. <code class="language-plaintext highlighter-rouge">List&lt;String&gt;[]</code>, <code class="language-plaintext highlighter-rouge">new E[]</code> 와 같은 것을 만들려고 하면 제네릭 배열 생성이라는 오류가 발생한다. 제네릭 배열이 생성되지 않는 이유는 형 안전성이 보장되지 않기 때문이다. 아래의 코드를 보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 제네릭 배열 생성이 허용되지 않는 이유 - 아래의 코드는 컴파일되지 않는다!</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[]</span> <span class="n">stringLists</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[</span><span class="mi">1</span><span class="o">];</span>   <span class="c1">// (1)</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">intList</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="mi">42</span><span class="o">);</span>          <span class="c1">// (2)</span>
<span class="nc">Object</span><span class="o">[]</span> <span class="n">objects</span> <span class="o">=</span> <span class="n">stringLists</span><span class="o">;</span>                     <span class="c1">// (3)</span>
<span class="n">objects</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">intList</span><span class="o">;</span>                               <span class="c1">// (4)</span>
<span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">stringLists</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>                   <span class="c1">// (5)</span>
</code></pre></div></div>

<p>(1)이 문제없이 컴파일이 된다면, 제네릭 배열이 만들어질 것이다. (2)는 하나의 원소를 갖는 배열 <code class="language-plaintext highlighter-rouge">List&lt;Integer&gt;</code>를 초기화한다. (3)은 <code class="language-plaintext highlighter-rouge">List&lt;String&gt;</code> 배열을 Object 배열 변수에 대입한다. 배열은 공변 자료형이므로, 가능하다. (4) 에서는 <code class="language-plaintext highlighter-rouge">List&lt;Integer&gt;</code>를 Object 배열에 있는 유일한 원소에 대입한다. 제네릭이 형 삭제를 통해 구현되므로 여기에도 하자는 없다. 하지만 <code class="language-plaintext highlighter-rouge">List&lt;String&gt;</code>만 들어간다고 만들어둔 배열에 <code class="language-plaintext highlighter-rouge">List&lt;Integer&gt;</code>을 저장한것이다. (5)에서는 저장된 원소를 꺼내는 작업을 하는데 사실을 Integer값을 꺼내서 String으로 변환하려는 것이다. 그래서 ClassCastException이 발생한다. 그래서 컴파일러는 (1)에서 오류를 발생시키는 것이다.</p>

<p><code class="language-plaintext highlighter-rouge">List&lt;E&gt;</code>는 성능이 저하되거나 코드가 길어질 수는 있겠으나, 형 안전성과 호환성은 좋아진다.</p>

<p>예를 들어, 동기화된 리스트가 하나 있고 리스트에 원소의 자료형과 같은 자료형의 값 두 개를 인자로 받는 함수가 하나 있다고 하자. 이 함수는 리스트의 원소가 정수면 모두 더하거나 곱하고, 문자열이면 모든 문자열 연결하여 반환하는 함수이다. 이렇게 리스트를 줄이는 것이다. 이러한 함수를 제네릭 없이 작성한다면 아래와 같은 모습일 것이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="nc">Object</span> <span class="nf">reduce</span><span class="o">(</span><span class="nc">List</span> <span class="n">list</span><span class="o">,</span> <span class="nc">Function</span> <span class="n">f</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">initVal</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">synchronized</span><span class="o">(</span><span class="n">list</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Object</span> <span class="n">result</span> <span class="o">=</span> <span class="n">initVal</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Object</span> <span class="n">o</span> <span class="o">:</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="n">o</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">interface</span> <span class="nc">Function</span> <span class="o">{</span>
    <span class="nc">Object</span> <span class="nf">apply</span><span class="o">(</span><span class="nc">Object</span> <span class="n">artg1</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">arg2</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>동기화 영역 안에서는 “불가해 메서드”를 호출하면 안된다. 그러니 락을 건 상태에서 리스트를 복사한 다음, 복사본에 작업하도록 메서드를 수정해야 한다. 1.5 이전의 자바에서는 List의 toArray 메서드를 사용한다. 내부적으로 리스트에 락을 걸기 때문이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 제네릭 없이 작성한 reduce 함수. 병행성 문제는 없다.</span>
<span class="kd">static</span> <span class="nc">Object</span> <span class="nf">reduce</span><span class="o">(</span><span class="nc">List</span> <span class="n">list</span><span class="o">,</span> <span class="nc">Function</span> <span class="n">f</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">initVal</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Object</span><span class="o">[]</span> <span class="n">snapshot</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">toArray</span><span class="o">();</span> <span class="c1">// 리스트에 내부적으로 락을 건다</span>
    <span class="nc">Object</span> <span class="n">result</span> <span class="o">=</span> <span class="n">initVal</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">Object</span> <span class="n">o</span> <span class="o">:</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="n">o</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>이런 작업을 제네릭으로 하게 되면 앞서 말한 문제들을 만나게 된다. Function 인터페이스와 reduce 메서드를 제네릭 버전으로 바꿔보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="no">E</span> <span class="nf">reduce</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">,</span> <span class="nc">Function</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">,</span> <span class="no">E</span> <span class="n">initVal</span><span class="o">)</span> <span class="o">{</span>
    <span class="no">E</span><span class="o">[]</span> <span class="n">snapshot</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">toArray</span><span class="o">();</span> <span class="c1">// 리스트에 내부적으로 락을 건다</span>
    <span class="no">E</span> <span class="n">result</span> <span class="o">=</span> <span class="n">initVal</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="no">E</span> <span class="n">e</span> <span class="o">:</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">interface</span> <span class="nc">Function</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="no">T</span> <span class="nf">apply</span><span class="o">(</span><span class="no">T</span> <span class="n">arg1</span><span class="o">,</span> <span class="no">T</span> <span class="n">arg2</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>이렇게 만들고 컴파일하면 오류를가 발생한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Practice</span><span class="o">.</span><span class="na">java</span><span class="o">:</span> <span class="n">incompatible</span> <span class="n">types</span>
<span class="n">found</span> <span class="o">:</span> <span class="nc">Object</span><span class="o">[],</span> <span class="nl">required:</span> <span class="no">E</span><span class="o">[]</span>
<span class="no">E</span><span class="o">[]</span> <span class="n">snapshot</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">toArray</span><span class="o">();</span> <span class="c1">// 리스트에 락을 건다</span>
                           <span class="err">＾</span>
</code></pre></div></div>

<p>Object 배열을 E 배열로 형변환 하면 OK 아닌가? 라고 생각할 수 있지만 그러면 새로운 경고가 뜬다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Practice</span><span class="o">.</span><span class="na">java</span><span class="o">:</span> <span class="nl">warning:</span> <span class="o">[</span><span class="n">unchecked</span><span class="o">]</span> <span class="n">unchecked</span> <span class="n">cast</span>
<span class="n">found</span> <span class="o">:</span> <span class="nc">Object</span><span class="o">[],</span> <span class="nl">required:</span> <span class="no">E</span><span class="o">[]</span>
<span class="no">E</span><span class="o">[]</span> <span class="n">snapshot</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">toArray</span><span class="o">();</span> <span class="c1">// 리스트에 락을 건다</span>
                           <span class="err">＾</span>
</code></pre></div></div>

<p>컴파일러는 실행 도중에 형변환이 안전하게 이루어질지 검사할 수 없다는 뜻이다. 실행 시에 E가 무슨 자료형이 될지 알 수 없기 때문이다. 원소의 자료형 정보는 프로그램이 실행될 때에는 제네릭에서 삭제된다.</p>

<p>그렇다면 어떻게 만들어야 할까? 단순하다 배열 대신 리스트를 사용하면 된다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="no">E</span> <span class="nf">reduce</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">,</span> <span class="nc">Function</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">,</span> <span class="no">E</span> <span class="n">initVal</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">snapshot</span><span class="o">;</span>
    <span class="kd">synchronized</span><span class="o">(</span><span class="n">list</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">snapshot</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;(</span><span class="n">list</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="no">E</span> <span class="n">result</span> <span class="o">=</span> <span class="n">initVal</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="no">E</span> <span class="n">e</span> <span class="o">:</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">interface</span> <span class="nc">Function</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="no">T</span> <span class="nf">apply</span><span class="o">(</span><span class="no">T</span> <span class="n">arg1</span><span class="o">,</span> <span class="no">T</span> <span class="n">arg2</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>앞에 나왔던 코드들 보다 길지만, 실행 도중에 ClassCastException이 발생할 일이 없으므로 그만한 값어치가 있다.</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
      
      
      
      

      
      
        <div class="post-nav" id="post-nav-id">
          <div class="post-nav-next post-nav-item">
            
              <a href="/effective%20java/2019/11/04/used-generic-type/" rel="next" title="[Effective Java] 가능하면 제네릭 자료형으로 만들 것">
                <i class="fa fa-chevron-left"></i> [Effective Java] 가능하면 제네릭 자료형으로 만들 것
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/effective%20java/2019/11/01/delete-unchecked-warning/" rel="prev" title="[Effective Java] 무점검 경고를 제거하라">
                [Effective Java] 무점검 경고를 제거하라 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      
      

      
    </footer>
  </article>

  <div class="post-spread">
    
  </div>
</div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          

  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      
        
        
        




      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            목차
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            흝어보기
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/assets/images/avatar.gif"
               alt="Kim BoWoon" />
          <p class="site-author-name" itemprop="name">Kim BoWoon</p>
           
              <p class="site-description motion-element" itemprop="description">https://kimbowoon.github.io/</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">38</span>
                <span class="site-state-item-name">포스트</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">카테고리</span>
              </a>
            </div>
          

          

        </nav>

        
        
        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            





            
              <div class="post-toc-content">
    <ol class=nav>
      <li class="nav-item nav-level-1"> <a class="nav-link" href="#배열과-제네릭의-차이"> <span class="nav-number">1</span> <span class="nav-text">배열과 제네릭의 차이</span> </a> <ol class="nav-child"> <ol class="nav-child"> <ol class="nav-child"> <ol class="nav-child"> <ol class="nav-child">
    </ol>
  </div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>

        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Kim BoWoon</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://jekyllrb.com">Jekyll</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/simpleyyt/jekyll-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>





















  
   
  
  
  
  
  
  <script type="text/javascript" src="/assets/lib/jquery/index.js?v=2.1.3"></script>

  
  
  
  
  
  <script type="text/javascript" src="/assets/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  
  
  
  
  <script type="text/javascript" src="/assets/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  
  
  
  
  <script type="text/javascript" src="/assets/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  
  
  
  
  <script type="text/javascript" src="/assets/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  
  
  
  
  <script type="text/javascript" src="/assets/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/assets/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/assets/js/src/motion.js?v=5.1.1"></script>



  
  

  <script type="text/javascript" src="/assets/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/assets/js/src/post-details.js?v=5.1.1"></script>


  


  <script type="text/javascript" src="/assets/js/src/bootstrap.js?v=5.1.1"></script>



  


  

    
      <script id="dsq-count-scr" src="https://kimbowoon.disqus.com/count.js" async></script>
    

    
      
      <script type="text/javascript">
          var disqus_config = function () {
              this.page.url = 'http://localhost:4000/effective%20java/2019/11/02/not-array-used-List/';
              this.page.identifier = '/effective%20java/2019/11/02/not-array-used-List/';
              this.page.title = '[Effective Java] 배열 대신 리스트를 써라';
          };
          var d = document, s = d.createElement('script');
          s.src = 'https://kimbowoon.disqus.com/embed.js';
          s.setAttribute('data-timestamp', '' + +new Date());
          (d.head || d.body).appendChild(s);
      </script>
      
    

  




	





  





  




  





  






  

  

  
  


  

  

  

</body>
</html>

