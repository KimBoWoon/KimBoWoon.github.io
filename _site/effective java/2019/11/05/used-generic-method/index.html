
<!doctype html>














<html class="theme-next muse use-motion" lang="ko">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/assets/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/assets/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/assets/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="" />





  <link rel="alternate" href="/atom.xml" title="Notepad" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/assets/favicon.ico?v=5.1.1" />
















<meta name="description" content="메서드 제네릭화 제네릭화 혜택을 받는 것는 클래스 뿐만이 아니다 메서드도 혜택을 받는다. 부가적 기능을 제공하는 static 유틸리티 메서드는 특히 제네릭화하기 좋은 후보다. 두 집합의 합집합을 반환하는 메서드를 만들어 보자. // 무인자 자료형 사용 - 권할 수 없는 방법 public static Set union(Set s1, Set s2) { Set result = new HashSet(s1); result.addAll(s2); return result; } 컴파일은 되지만 경고 메시지가 나온다. Union.java: warning: [unchecked] unchecked call to HashSet(Collection&amp;lt;? extends E&amp;gt;) as a member of raw type HashSet Set result = new HashSet(s1); ＾ Union.java: warning: [unchecked] unchecked call to addAll(Collection&amp;lt;? extends E&amp;gt;) as a member of raw type Set result.addAll(s2); ＾ 경고를 없애고 형 안전성이 보장된 메서드를 구현해보자. // 무인자 자료형 사용 - 권할 수 없는 방법 public static &amp;lt;E&amp;gt; Set&amp;lt;E&amp;gt; union(Set&amp;lt;E&amp;gt; s1, Set&amp;lt;E&amp;gt; s2) { Set&amp;lt;E&amp;gt; result = new HashSet&amp;lt;E&amp;gt;(s1); result.addAll(s2); return result; } 컴파일러는 전달받은 인자를 보고 E의 자료형을 유추한다. 지금은 Set&amp;lt;String&amp;gt;이므로 E가 String인것을 알 수 있다. 이 과정을 자료형 유추라고 한다. 이 과정을 응용하면 더욱 간결한 코드를 만들 수 있다. 아래를 보자. // 생성자를 통한 형인자 자료형 객체 생성 Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; anagrams = new HashMap&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt;(); 왼쪽과 오른쪽에 똑같이 적어줘야 한다는 불편함이 있다. 제네릭 정적 팩터리 메서드를 만들면 한결 깔끔해진다. // 제네릭 정적 팩터리 메서드 - 아무 인자도 받지 않는 HashMap 생성자 public static &amp;lt;K, V&amp;gt; HashMap&amp;lt;K, V&amp;gt; newHashMap() { return new HashMap&amp;lt;K, V&amp;gt;(); } 이 생성자를 사용하면 중복되는 형인자를 제거하여 간결한 코드를 만들 수 있다. // 정적 팩터리 메서드를 통한 형인자 자료형 객체 생성 Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; anagrams = newHashMap(); Java 1.6 버전까지는 이렇게 사용했지만 지금은 생성자에도 자료형 추론이 지원된다. 제네릭 싱글턴 패턴 가령 T 형의 값을 받고 반환하는 함수를 나타내는 인터페이스가 있다고 하자. public interface UnaryFunction&amp;lt;T&amp;gt; { T apply(T arg); } 항등함수를 구현하면 아래와 같이 될것이다. 항등함수는 무상태 함수이므로, 필요할 때마다 새 함수를 만드는 것은 낭비이다. 제네릭이 실체화 되는 자료형이었다면 자료형마다 별도의 항등함수가 필요하겠지만, 자료형 정보는 컴파일이 끝나면 삭제된다는 점을 이용하면 제네릭 싱글턴 하나만 있으면 된다. private static UnaryFunction&amp;lt;Object&amp;gt; IDENTITY_FUNCTION = new UnaryFunction&amp;lt;Object&amp;gt;() { public Object apply(Object arg) { return arg; } }; // IDENTITY_FUNCTION은 무상태 객체고 형인자는 비한정 인자이므로 // 모든 자료형이 같은 객체를 공유해도 안전하다. @SuppressWarnings(&quot;unchecked&quot;) public static &amp;lt;T&amp;gt; UnaryFunction&amp;lt;T&amp;gt; identityFunction() { return (UnaryFunction&amp;lt;T&amp;gt;) IDENTITY_FUNCTION; } 인자를 수정 없이 반환하므로, T가 무엇이건 간에 UnaryFunction&amp;lt;T&amp;gt;인 것처럼 써도 형 안전성이 보장된다. 아래의 몇가지 예제 프로그램을 적어두겠다. // 제네릭 싱글턴 사용 예제 public static void main(String[] args) { String[] strings = { &quot;jute&quot;, &quot;hemp&quot;, &quot;nylon&quot; }; UnaryFunction&amp;lt;String&amp;gt; sameString = identityFunction(); for (String s : strings) { System.out.println(sameString.apply(s)); } Number[] numbers = { 1, 2.0, 3L }; UnaryFunction&amp;lt;Number&amp;gt; sameNumber = identityFunction(); for (Number n : numbers) { System.out.println(sameNumber.apply(n)); } } 재귀적 자료형 한정 상대적으로 사용 빈도가 낮긴 하나, 형인자가 포함된 표현식으로 형인자를 한정하는 것도 가능하다. 재귀적 자료형 한정은 Comparable 인터페이스와 함께 가장 흔히 쓰인다. public interface Comparable&amp;lt;T&amp;gt; { int compareTo(T o); } 이 인터페이스의 형인자 T는 Comparable&amp;lt;T&amp;gt;를 구현하는 자료형의 객체와 비교 가능한 객체의 자료형이다. 실제로 거의 모든 자료형은 같은 자료형 객체하고만 비교 할 수 있다. 이 인터페이스를 구현하는 원소들의 리스트를 인자로 받는 메서드는 많다. 정렬, 탐색, 최댓값 및 최솟값을 계산하기도 한다. 그런데 그런 작업이 가능하려면 리스트 내의 원소들이 서로 비교 가능해한다. 이런 조건을 어떻게 표현하는지 알아보자. // 리스트의 최대 값 반환 - 재귀적 자료형 한정 사용 public static &amp;lt;T extends Comparable&amp;lt;T&amp;gt;&amp;gt; T max(List&amp;lt;T&amp;gt; list) { Iterator&amp;lt;T&amp;gt; i = list.iterator(); T result - i.next(); while (i.hasNext()) { T t = i.next(); ir (t.compareTo(result) &amp;gt; 0) { result = t; } } return result; } &amp;lt;T extends Comparable&amp;lt;T&amp;gt;&amp;gt; 이 부분은 “자기 자신과 비교 가능한 모든 자료형 T”라는 뜻으로 읽을 수 있다. 상호 비교 가능성이라는 개념을 어느 정도 정확하게 표현하는 문장이다. 재귀적 자료형 한정은 이보다 복잡하게 쓰일 수도 있으나, 다행히도 흔한 일은 아니다. 위에 모두를 이해하고 와일드카드 용법을 이해하게 되면 실무에서 만나는 재귀적 자료형 한정 용법 상당수를 다룰 수 있게 될 것이다.">
<meta name="keywords" content="Jekyll, NexT">
<meta property="og:type" content="article">
<meta property="og:title" content="[Effective Java] 가능하면 제네릭 메서드로 만들 것">
<meta property="og:url" content="http://localhost:4000/effective%20java/2019/11/05/used-generic-method/">
<meta property="og:site_name" content="Notepad">
<meta property="og:description" content="메서드 제네릭화 제네릭화 혜택을 받는 것는 클래스 뿐만이 아니다 메서드도 혜택을 받는다. 부가적 기능을 제공하는 static 유틸리티 메서드는 특히 제네릭화하기 좋은 후보다. 두 집합의 합집합을 반환하는 메서드를 만들어 보자. // 무인자 자료형 사용 - 권할 수 없는 방법 public static Set union(Set s1, Set s2) { Set result = new HashSet(s1); result.addAll(s2); return result; } 컴파일은 되지만 경고 메시지가 나온다. Union.java: warning: [unchecked] unchecked call to HashSet(Collection&amp;lt;? extends E&amp;gt;) as a member of raw type HashSet Set result = new HashSet(s1); ＾ Union.java: warning: [unchecked] unchecked call to addAll(Collection&amp;lt;? extends E&amp;gt;) as a member of raw type Set result.addAll(s2); ＾ 경고를 없애고 형 안전성이 보장된 메서드를 구현해보자. // 무인자 자료형 사용 - 권할 수 없는 방법 public static &amp;lt;E&amp;gt; Set&amp;lt;E&amp;gt; union(Set&amp;lt;E&amp;gt; s1, Set&amp;lt;E&amp;gt; s2) { Set&amp;lt;E&amp;gt; result = new HashSet&amp;lt;E&amp;gt;(s1); result.addAll(s2); return result; } 컴파일러는 전달받은 인자를 보고 E의 자료형을 유추한다. 지금은 Set&amp;lt;String&amp;gt;이므로 E가 String인것을 알 수 있다. 이 과정을 자료형 유추라고 한다. 이 과정을 응용하면 더욱 간결한 코드를 만들 수 있다. 아래를 보자. // 생성자를 통한 형인자 자료형 객체 생성 Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; anagrams = new HashMap&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt;(); 왼쪽과 오른쪽에 똑같이 적어줘야 한다는 불편함이 있다. 제네릭 정적 팩터리 메서드를 만들면 한결 깔끔해진다. // 제네릭 정적 팩터리 메서드 - 아무 인자도 받지 않는 HashMap 생성자 public static &amp;lt;K, V&amp;gt; HashMap&amp;lt;K, V&amp;gt; newHashMap() { return new HashMap&amp;lt;K, V&amp;gt;(); } 이 생성자를 사용하면 중복되는 형인자를 제거하여 간결한 코드를 만들 수 있다. // 정적 팩터리 메서드를 통한 형인자 자료형 객체 생성 Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; anagrams = newHashMap(); Java 1.6 버전까지는 이렇게 사용했지만 지금은 생성자에도 자료형 추론이 지원된다. 제네릭 싱글턴 패턴 가령 T 형의 값을 받고 반환하는 함수를 나타내는 인터페이스가 있다고 하자. public interface UnaryFunction&amp;lt;T&amp;gt; { T apply(T arg); } 항등함수를 구현하면 아래와 같이 될것이다. 항등함수는 무상태 함수이므로, 필요할 때마다 새 함수를 만드는 것은 낭비이다. 제네릭이 실체화 되는 자료형이었다면 자료형마다 별도의 항등함수가 필요하겠지만, 자료형 정보는 컴파일이 끝나면 삭제된다는 점을 이용하면 제네릭 싱글턴 하나만 있으면 된다. private static UnaryFunction&amp;lt;Object&amp;gt; IDENTITY_FUNCTION = new UnaryFunction&amp;lt;Object&amp;gt;() { public Object apply(Object arg) { return arg; } }; // IDENTITY_FUNCTION은 무상태 객체고 형인자는 비한정 인자이므로 // 모든 자료형이 같은 객체를 공유해도 안전하다. @SuppressWarnings(&quot;unchecked&quot;) public static &amp;lt;T&amp;gt; UnaryFunction&amp;lt;T&amp;gt; identityFunction() { return (UnaryFunction&amp;lt;T&amp;gt;) IDENTITY_FUNCTION; } 인자를 수정 없이 반환하므로, T가 무엇이건 간에 UnaryFunction&amp;lt;T&amp;gt;인 것처럼 써도 형 안전성이 보장된다. 아래의 몇가지 예제 프로그램을 적어두겠다. // 제네릭 싱글턴 사용 예제 public static void main(String[] args) { String[] strings = { &quot;jute&quot;, &quot;hemp&quot;, &quot;nylon&quot; }; UnaryFunction&amp;lt;String&amp;gt; sameString = identityFunction(); for (String s : strings) { System.out.println(sameString.apply(s)); } Number[] numbers = { 1, 2.0, 3L }; UnaryFunction&amp;lt;Number&amp;gt; sameNumber = identityFunction(); for (Number n : numbers) { System.out.println(sameNumber.apply(n)); } } 재귀적 자료형 한정 상대적으로 사용 빈도가 낮긴 하나, 형인자가 포함된 표현식으로 형인자를 한정하는 것도 가능하다. 재귀적 자료형 한정은 Comparable 인터페이스와 함께 가장 흔히 쓰인다. public interface Comparable&amp;lt;T&amp;gt; { int compareTo(T o); } 이 인터페이스의 형인자 T는 Comparable&amp;lt;T&amp;gt;를 구현하는 자료형의 객체와 비교 가능한 객체의 자료형이다. 실제로 거의 모든 자료형은 같은 자료형 객체하고만 비교 할 수 있다. 이 인터페이스를 구현하는 원소들의 리스트를 인자로 받는 메서드는 많다. 정렬, 탐색, 최댓값 및 최솟값을 계산하기도 한다. 그런데 그런 작업이 가능하려면 리스트 내의 원소들이 서로 비교 가능해한다. 이런 조건을 어떻게 표현하는지 알아보자. // 리스트의 최대 값 반환 - 재귀적 자료형 한정 사용 public static &amp;lt;T extends Comparable&amp;lt;T&amp;gt;&amp;gt; T max(List&amp;lt;T&amp;gt; list) { Iterator&amp;lt;T&amp;gt; i = list.iterator(); T result - i.next(); while (i.hasNext()) { T t = i.next(); ir (t.compareTo(result) &amp;gt; 0) { result = t; } } return result; } &amp;lt;T extends Comparable&amp;lt;T&amp;gt;&amp;gt; 이 부분은 “자기 자신과 비교 가능한 모든 자료형 T”라는 뜻으로 읽을 수 있다. 상호 비교 가능성이라는 개념을 어느 정도 정확하게 표현하는 문장이다. 재귀적 자료형 한정은 이보다 복잡하게 쓰일 수도 있으나, 다행히도 흔한 일은 아니다. 위에 모두를 이해하고 와일드카드 용법을 이해하게 되면 실무에서 만나는 재귀적 자료형 한정 용법 상당수를 다룰 수 있게 될 것이다.">
<meta property="og:locale" content="ko">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="[Effective Java] 가능하면 제네릭 메서드로 만들 것">
<meta name="twitter:description" content="메서드 제네릭화 제네릭화 혜택을 받는 것는 클래스 뿐만이 아니다 메서드도 혜택을 받는다. 부가적 기능을 제공하는 static 유틸리티 메서드는 특히 제네릭화하기 좋은 후보다. 두 집합의 합집합을 반환하는 메서드를 만들어 보자. // 무인자 자료형 사용 - 권할 수 없는 방법 public static Set union(Set s1, Set s2) { Set result = new HashSet(s1); result.addAll(s2); return result; } 컴파일은 되지만 경고 메시지가 나온다. Union.java: warning: [unchecked] unchecked call to HashSet(Collection&amp;lt;? extends E&amp;gt;) as a member of raw type HashSet Set result = new HashSet(s1); ＾ Union.java: warning: [unchecked] unchecked call to addAll(Collection&amp;lt;? extends E&amp;gt;) as a member of raw type Set result.addAll(s2); ＾ 경고를 없애고 형 안전성이 보장된 메서드를 구현해보자. // 무인자 자료형 사용 - 권할 수 없는 방법 public static &amp;lt;E&amp;gt; Set&amp;lt;E&amp;gt; union(Set&amp;lt;E&amp;gt; s1, Set&amp;lt;E&amp;gt; s2) { Set&amp;lt;E&amp;gt; result = new HashSet&amp;lt;E&amp;gt;(s1); result.addAll(s2); return result; } 컴파일러는 전달받은 인자를 보고 E의 자료형을 유추한다. 지금은 Set&amp;lt;String&amp;gt;이므로 E가 String인것을 알 수 있다. 이 과정을 자료형 유추라고 한다. 이 과정을 응용하면 더욱 간결한 코드를 만들 수 있다. 아래를 보자. // 생성자를 통한 형인자 자료형 객체 생성 Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; anagrams = new HashMap&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt;(); 왼쪽과 오른쪽에 똑같이 적어줘야 한다는 불편함이 있다. 제네릭 정적 팩터리 메서드를 만들면 한결 깔끔해진다. // 제네릭 정적 팩터리 메서드 - 아무 인자도 받지 않는 HashMap 생성자 public static &amp;lt;K, V&amp;gt; HashMap&amp;lt;K, V&amp;gt; newHashMap() { return new HashMap&amp;lt;K, V&amp;gt;(); } 이 생성자를 사용하면 중복되는 형인자를 제거하여 간결한 코드를 만들 수 있다. // 정적 팩터리 메서드를 통한 형인자 자료형 객체 생성 Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; anagrams = newHashMap(); Java 1.6 버전까지는 이렇게 사용했지만 지금은 생성자에도 자료형 추론이 지원된다. 제네릭 싱글턴 패턴 가령 T 형의 값을 받고 반환하는 함수를 나타내는 인터페이스가 있다고 하자. public interface UnaryFunction&amp;lt;T&amp;gt; { T apply(T arg); } 항등함수를 구현하면 아래와 같이 될것이다. 항등함수는 무상태 함수이므로, 필요할 때마다 새 함수를 만드는 것은 낭비이다. 제네릭이 실체화 되는 자료형이었다면 자료형마다 별도의 항등함수가 필요하겠지만, 자료형 정보는 컴파일이 끝나면 삭제된다는 점을 이용하면 제네릭 싱글턴 하나만 있으면 된다. private static UnaryFunction&amp;lt;Object&amp;gt; IDENTITY_FUNCTION = new UnaryFunction&amp;lt;Object&amp;gt;() { public Object apply(Object arg) { return arg; } }; // IDENTITY_FUNCTION은 무상태 객체고 형인자는 비한정 인자이므로 // 모든 자료형이 같은 객체를 공유해도 안전하다. @SuppressWarnings(&quot;unchecked&quot;) public static &amp;lt;T&amp;gt; UnaryFunction&amp;lt;T&amp;gt; identityFunction() { return (UnaryFunction&amp;lt;T&amp;gt;) IDENTITY_FUNCTION; } 인자를 수정 없이 반환하므로, T가 무엇이건 간에 UnaryFunction&amp;lt;T&amp;gt;인 것처럼 써도 형 안전성이 보장된다. 아래의 몇가지 예제 프로그램을 적어두겠다. // 제네릭 싱글턴 사용 예제 public static void main(String[] args) { String[] strings = { &quot;jute&quot;, &quot;hemp&quot;, &quot;nylon&quot; }; UnaryFunction&amp;lt;String&amp;gt; sameString = identityFunction(); for (String s : strings) { System.out.println(sameString.apply(s)); } Number[] numbers = { 1, 2.0, 3L }; UnaryFunction&amp;lt;Number&amp;gt; sameNumber = identityFunction(); for (Number n : numbers) { System.out.println(sameNumber.apply(n)); } } 재귀적 자료형 한정 상대적으로 사용 빈도가 낮긴 하나, 형인자가 포함된 표현식으로 형인자를 한정하는 것도 가능하다. 재귀적 자료형 한정은 Comparable 인터페이스와 함께 가장 흔히 쓰인다. public interface Comparable&amp;lt;T&amp;gt; { int compareTo(T o); } 이 인터페이스의 형인자 T는 Comparable&amp;lt;T&amp;gt;를 구현하는 자료형의 객체와 비교 가능한 객체의 자료형이다. 실제로 거의 모든 자료형은 같은 자료형 객체하고만 비교 할 수 있다. 이 인터페이스를 구현하는 원소들의 리스트를 인자로 받는 메서드는 많다. 정렬, 탐색, 최댓값 및 최솟값을 계산하기도 한다. 그런데 그런 작업이 가능하려면 리스트 내의 원소들이 서로 비교 가능해한다. 이런 조건을 어떻게 표현하는지 알아보자. // 리스트의 최대 값 반환 - 재귀적 자료형 한정 사용 public static &amp;lt;T extends Comparable&amp;lt;T&amp;gt;&amp;gt; T max(List&amp;lt;T&amp;gt; list) { Iterator&amp;lt;T&amp;gt; i = list.iterator(); T result - i.next(); while (i.hasNext()) { T t = i.next(); ir (t.compareTo(result) &amp;gt; 0) { result = t; } } return result; } &amp;lt;T extends Comparable&amp;lt;T&amp;gt;&amp;gt; 이 부분은 “자기 자신과 비교 가능한 모든 자료형 T”라는 뜻으로 읽을 수 있다. 상호 비교 가능성이라는 개념을 어느 정도 정확하게 표현하는 문장이다. 재귀적 자료형 한정은 이보다 복잡하게 쓰일 수도 있으나, 다행히도 흔한 일은 아니다. 위에 모두를 이해하고 와일드카드 용법을 이해하게 되면 실무에서 만나는 재귀적 자료형 한정 용법 상당수를 다룰 수 있게 될 것이다.">


<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '작성자'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://localhost:4000/"/>





  <title>[Effective Java] 가능하면 제네릭 메서드로 만들 것</title>
  
















</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="ko">

  
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Notepad</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            홈
          </a>
        </li>
      
        
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            아카이브
          </a>
        </li>
      
        
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            태그
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

<div id="posts" class="posts-expand">
  
  

  

  
  
  

  <article class="post post-type- " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://localhost:4000/effective%20java/2019/11/05/used-generic-method/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kim BoWoon">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="assets/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Notepad">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
          
          
            [Effective Java] 가능하면 제네릭 메서드로 만들 것
          
        </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">작성일</span>
              
              <time title="" itemprop="dateCreated datePublished" datetime="2019-11-05T06:19:42+09:00">
                2019-11-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/category/#/Effective%20Java" itemprop="url" rel="index">
                    <span itemprop="name">Effective Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/effective%20java/2019/11/05/used-generic-method/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="/effective%20java/2019/11/05/used-generic-method/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          
            
                <div class="post-description">
                    
                </div>
            
          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="메서드-제네릭화">메서드 제네릭화</h1>
<p>제네릭화 혜택을 받는 것는 클래스 뿐만이 아니다 메서드도 혜택을 받는다. 부가적 기능을 제공하는 static 유틸리티 메서드는 특히 제네릭화하기 좋은 후보다. 두 집합의 합집합을 반환하는 메서드를 만들어 보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 무인자 자료형 사용 - 권할 수 없는 방법</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="nc">Set</span> <span class="nf">union</span><span class="o">(</span><span class="nc">Set</span> <span class="n">s1</span><span class="o">,</span> <span class="nc">Set</span> <span class="n">s2</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Set</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">(</span><span class="n">s1</span><span class="o">);</span>
    <span class="n">result</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">s2</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>컴파일은 되지만 경고 메시지가 나온다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Union</span><span class="o">.</span><span class="na">java</span><span class="o">:</span> <span class="nl">warning:</span> <span class="o">[</span><span class="n">unchecked</span><span class="o">]</span> <span class="n">unchecked</span> <span class="n">call</span> <span class="n">to</span>
<span class="nf">HashSet</span><span class="o">(</span><span class="nc">Collection</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">E</span><span class="o">&gt;)</span> <span class="n">as</span> <span class="n">a</span> <span class="n">member</span> <span class="n">of</span> <span class="n">raw</span> <span class="n">type</span> <span class="nc">HashSet</span>
<span class="nc">Set</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">(</span><span class="n">s1</span><span class="o">);</span>
            <span class="err">＾</span>
<span class="nc">Union</span><span class="o">.</span><span class="na">java</span><span class="o">:</span> <span class="nl">warning:</span> <span class="o">[</span><span class="n">unchecked</span><span class="o">]</span> <span class="n">unchecked</span> <span class="n">call</span> <span class="n">to</span>
<span class="nf">addAll</span><span class="o">(</span><span class="nc">Collection</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">E</span><span class="o">&gt;)</span> <span class="n">as</span> <span class="n">a</span> <span class="n">member</span> <span class="n">of</span> <span class="n">raw</span> <span class="n">type</span> <span class="nc">Set</span>
<span class="n">result</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">s2</span><span class="o">);</span>
             <span class="err">＾</span>
</code></pre></div></div>

<p>경고를 없애고 형 안전성이 보장된 메서드를 구현해보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 무인자 자료형 사용 - 권할 수 없는 방법</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="nf">union</span><span class="o">(</span><span class="nc">Set</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">s1</span><span class="o">,</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">s2</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Set</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;(</span><span class="n">s1</span><span class="o">);</span>
    <span class="n">result</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">s2</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>컴파일러는 전달받은 인자를 보고 E의 자료형을 유추한다. 지금은 <code class="language-plaintext highlighter-rouge">Set&lt;String&gt;</code>이므로 E가 String인것을 알 수 있다. 이 과정을 자료형 유추라고 한다. 이 과정을 응용하면 더욱 간결한 코드를 만들 수 있다. 아래를 보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 생성자를 통한 형인자 자료형 객체 생성</span>
<span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">anagrams</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;();</span>
</code></pre></div></div>

<p>왼쪽과 오른쪽에 똑같이 적어줘야 한다는 불편함이 있다. 제네릭 정적 팩터리 메서드를 만들면 한결 깔끔해진다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 제네릭 정적 팩터리 메서드 - 아무 인자도 받지 않는 HashMap 생성자</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="nc">HashMap</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="nf">newHashMap</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>이 생성자를 사용하면 중복되는 형인자를 제거하여 간결한 코드를 만들 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 정적 팩터리 메서드를 통한 형인자 자료형 객체 생성</span>
<span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">anagrams</span> <span class="o">=</span> <span class="n">newHashMap</span><span class="o">();</span>
</code></pre></div></div>

<p>Java 1.6 버전까지는 이렇게 사용했지만 지금은 생성자에도 자료형 추론이 지원된다.</p>

<h1 id="제네릭-싱글턴-패턴">제네릭 싱글턴 패턴</h1>
<p>가령 T 형의 값을 받고 반환하는 함수를 나타내는 인터페이스가 있다고 하자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">UnaryFunction</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="no">T</span> <span class="nf">apply</span><span class="o">(</span><span class="no">T</span> <span class="n">arg</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>항등함수를 구현하면 아래와 같이 될것이다. 항등함수는 무상태 함수이므로, 필요할 때마다 새 함수를 만드는 것은 낭비이다. 제네릭이 실체화 되는 자료형이었다면 자료형마다 별도의 항등함수가 필요하겠지만, 자료형 정보는 컴파일이 끝나면 삭제된다는 점을 이용하면 제네릭 싱글턴 하나만 있으면 된다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">static</span> <span class="nc">UnaryFunction</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="no">IDENTITY_FUNCTION</span> <span class="o">=</span> 
    <span class="k">new</span> <span class="nc">UnaryFunction</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;()</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">apply</span><span class="o">(</span><span class="nc">Object</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span> 
            <span class="k">return</span> <span class="n">arg</span><span class="o">;</span> 
        <span class="o">}</span>
    <span class="o">};</span>

<span class="c1">// IDENTITY_FUNCTION은 무상태 객체고 형인자는 비한정 인자이므로</span>
<span class="c1">// 모든 자료형이 같은 객체를 공유해도 안전하다.</span>
<span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">"unchecked"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nc">UnaryFunction</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">identityFunction</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="o">(</span><span class="nc">UnaryFunction</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;)</span> <span class="no">IDENTITY_FUNCTION</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>인자를 수정 없이 반환하므로, T가 무엇이건 간에 <code class="language-plaintext highlighter-rouge">UnaryFunction&lt;T&gt;</code>인 것처럼 써도 형 안전성이 보장된다. 아래의 몇가지 예제 프로그램을 적어두겠다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 제네릭 싱글턴 사용 예제</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">String</span><span class="o">[]</span> <span class="n">strings</span> <span class="o">=</span> <span class="o">{</span> <span class="s">"jute"</span><span class="o">,</span> <span class="s">"hemp"</span><span class="o">,</span> <span class="s">"nylon"</span> <span class="o">};</span>
    <span class="nc">UnaryFunction</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">sameString</span> <span class="o">=</span> <span class="n">identityFunction</span><span class="o">();</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">s</span> <span class="o">:</span> <span class="n">strings</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">sameString</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">s</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="nc">Number</span><span class="o">[]</span> <span class="n">numbers</span> <span class="o">=</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span> <span class="mf">2.0</span><span class="o">,</span> <span class="mi">3L</span> <span class="o">};</span>
    <span class="nc">UnaryFunction</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;</span> <span class="n">sameNumber</span> <span class="o">=</span> <span class="n">identityFunction</span><span class="o">();</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">Number</span> <span class="n">n</span> <span class="o">:</span> <span class="n">numbers</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">sameNumber</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">n</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h1 id="재귀적-자료형-한정">재귀적 자료형 한정</h1>
<p>상대적으로 사용 빈도가 낮긴 하나, 형인자가 포함된 표현식으로 형인자를 한정하는 것도 가능하다. 재귀적 자료형 한정은 Comparable 인터페이스와 함께 가장 흔히 쓰인다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Comparable</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="nf">compareTo</span><span class="o">(</span><span class="no">T</span> <span class="n">o</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>이 인터페이스의 형인자 T는 <code class="language-plaintext highlighter-rouge">Comparable&lt;T&gt;</code>를 구현하는 자료형의 객체와 비교 가능한 객체의 자료형이다. 실제로 거의 모든 자료형은 같은 자료형 객체하고만 비교 할 수 있다. 이 인터페이스를 구현하는 원소들의 리스트를 인자로 받는 메서드는 많다. 정렬, 탐색, 최댓값 및 최솟값을 계산하기도 한다. 그런데 그런 작업이 가능하려면 리스트 내의 원소들이 서로 비교 가능해한다. 이런 조건을 어떻게 표현하는지 알아보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 리스트의 최대 값 반환 - 재귀적 자료형 한정 사용</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span> <span class="kd">extends</span> <span class="nc">Comparable</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;&gt;</span> <span class="no">T</span> <span class="nf">max</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Iterator</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span>
    <span class="no">T</span> <span class="n">result</span> <span class="o">-</span> <span class="n">i</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">i</span><span class="o">.</span><span class="na">hasNext</span><span class="o">())</span> <span class="o">{</span>
        <span class="no">T</span> <span class="n">t</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
        <span class="n">ir</span> <span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">result</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">&lt;T extends Comparable&lt;T&gt;&gt;</code> 이 부분은 “자기 자신과 비교 가능한 모든 자료형 T”라는 뜻으로 읽을 수 있다. 상호 비교 가능성이라는 개념을 어느 정도 정확하게 표현하는 문장이다.</p>

<p>재귀적 자료형 한정은 이보다 복잡하게 쓰일 수도 있으나, 다행히도 흔한 일은 아니다. 위에 모두를 이해하고 와일드카드 용법을 이해하게 되면 실무에서 만나는 재귀적 자료형 한정 용법 상당수를 다룰 수 있게 될 것이다.</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
      
      
      
      

      
      
        <div class="post-nav" id="post-nav-id">
          <div class="post-nav-next post-nav-item">
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/effective%20java/2019/11/04/used-generic-type/" rel="prev" title="[Effective Java] 가능하면 제네릭 자료형으로 만들 것">
                [Effective Java] 가능하면 제네릭 자료형으로 만들 것 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      
      

      
    </footer>
  </article>

  <div class="post-spread">
    
  </div>
</div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          

  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      
        
        
        




      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            목차
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            흝어보기
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/assets/images/avatar.gif"
               alt="Kim BoWoon" />
          <p class="site-author-name" itemprop="name">Kim BoWoon</p>
           
              <p class="site-description motion-element" itemprop="description">https://kimbowoon.github.io/</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">37</span>
                <span class="site-state-item-name">포스트</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">카테고리</span>
              </a>
            </div>
          

          

        </nav>

        
        
        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            





            
              <div class="post-toc-content">
    <ol class=nav>
      <li class="nav-item nav-level-1"> <a class="nav-link" href="#메서드-제네릭화"> <span class="nav-number">1</span> <span class="nav-text">메서드 제네릭화</span> </a> <ol class="nav-child"> <ol class="nav-child"> <ol class="nav-child"> <ol class="nav-child"> <ol class="nav-child"> </li></ol> </li></ol> </li></ol> </li></ol> </li></ol> </li> <li class="nav-item nav-level-1"> <a class="nav-link" href="#제네릭-싱글턴-패턴"> <span class="nav-number">2</span> <span class="nav-text">제네릭 싱글턴 패턴</span> </a> <ol class="nav-child"> <ol class="nav-child"> <ol class="nav-child"> <ol class="nav-child"> <ol class="nav-child"> </li></ol> </li></ol> </li></ol> </li></ol> </li></ol> </li> <li class="nav-item nav-level-1"> <a class="nav-link" href="#재귀적-자료형-한정"> <span class="nav-number">3</span> <span class="nav-text">재귀적 자료형 한정</span> </a> <ol class="nav-child"> <ol class="nav-child"> <ol class="nav-child"> <ol class="nav-child"> <ol class="nav-child">
    </ol>
  </div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>

        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Kim BoWoon</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://jekyllrb.com">Jekyll</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/simpleyyt/jekyll-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>





















  
   
  
  
  
  
  
  <script type="text/javascript" src="/assets/lib/jquery/index.js?v=2.1.3"></script>

  
  
  
  
  
  <script type="text/javascript" src="/assets/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  
  
  
  
  <script type="text/javascript" src="/assets/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  
  
  
  
  <script type="text/javascript" src="/assets/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  
  
  
  
  <script type="text/javascript" src="/assets/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  
  
  
  
  <script type="text/javascript" src="/assets/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/assets/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/assets/js/src/motion.js?v=5.1.1"></script>



  
  

  <script type="text/javascript" src="/assets/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/assets/js/src/post-details.js?v=5.1.1"></script>


  


  <script type="text/javascript" src="/assets/js/src/bootstrap.js?v=5.1.1"></script>



  


  

    
      <script id="dsq-count-scr" src="https://kimbowoon.disqus.com/count.js" async></script>
    

    
      
      <script type="text/javascript">
          var disqus_config = function () {
              this.page.url = 'http://localhost:4000/effective%20java/2019/11/05/used-generic-method/';
              this.page.identifier = '/effective%20java/2019/11/05/used-generic-method/';
              this.page.title = '[Effective Java] 가능하면 제네릭 메서드로 만들 것';
          };
          var d = document, s = d.createElement('script');
          s.src = 'https://kimbowoon.disqus.com/embed.js';
          s.setAttribute('data-timestamp', '' + +new Date());
          (d.head || d.body).appendChild(s);
      </script>
      
    

  




	





  





  




  





  






  

  

  
  


  

  

  

</body>
</html>

